package run

import (
	"context"
	"crypto/x509"
	"encoding/pem"
	"errors"
	"flag"
	"fmt"
	"io/ioutil"
	"net"
	"os"
	"path/filepath"
	"strconv"

	"github.com/hashicorp/hcl"
	"github.com/spiffe/spire/pkg/agent"
	"github.com/spiffe/spire/pkg/common/catalog"
	"github.com/spiffe/spire/pkg/common/cli"
	"github.com/spiffe/spire/pkg/common/idutil"
	"github.com/spiffe/spire/pkg/common/log"
	"github.com/spiffe/spire/pkg/common/telemetry"
	"github.com/spiffe/spire/pkg/common/util"
)

const (
	defaultConfigPath = "conf/agent/agent.conf"

	defaultSocketPath = "./spire_api"

	// TODO: Make my defaults sane
	defaultDataDir  = "."
	defaultLogLevel = "INFO"
)

// RunConfig represents the available configurables for file
// and CLI options
type runConfig struct {
	AgentConfig   agentRunConfig             `hcl:"agent"`
	PluginConfigs catalog.HCLPluginConfigMap `hcl:"plugins"`
	Telemetry     telemetry.FileConfig       `hcl:"telemetry"`
}

type agentRunConfig struct {
	DataDir         string `hcl:"data_dir"`
	EnableSDS       bool   `hcl:"enable_sds"`
	LogFile         string `hcl:"log_file"`
	LogLevel        string `hcl:"log_level"`
	ServerAddress   string `hcl:"server_address"`
	ServerPort      int    `hcl:"server_port"`
	SocketPath      string `hcl:"socket_path"`
	TrustBundlePath string `hcl:"trust_bundle_path"`
	TrustDomain     string `hcl:"trust_domain"`
	JoinToken       string `hcl:"join_token"`

	ConfigPath string

	// Undocumented configurables
	ProfilingEnabled bool     `hcl:"profiling_enabled"`
	ProfilingPort    int      `hcl:"profiling_port"`
	ProfilingFreq    int      `hcl:"profiling_freq"`
	ProfilingNames   []string `hcl:"profiling_names"`
	Umask            string   `hcl:"umask"`
}

type agentConfig struct {
	agent.Config
	umask int
}

type RunCLI struct {
}

func (*RunCLI) Help() string {
	_, err := parseFlags([]string{"-h"})
	return err.Error()
}

func (*RunCLI) Run(args []string) int {
	cliConfig, err := parseFlags(args)
	if err != nil {
		fmt.Println(err.Error())
		return 1
	}

	fileConfig, err := parseFile(cliConfig.AgentConfig.ConfigPath)
	if err != nil {
		fmt.Println(err.Error())
		return 1
	}

	c := newDefaultConfig()

	// Get the plugin and telemetry configurations from the file
	c.PluginConfigs = fileConfig.PluginConfigs
	c.Telemetry = fileConfig.Telemetry

	err = mergeConfigs(c, fileConfig, cliConfig)
	if err != nil {
		fmt.Println(err.Error())
	}

	err = validateConfig(c)
	if err != nil {
		fmt.Println(err.Error())
	}

	cli.SetUmask(c.Log, c.umask)

	agt := agent.New(&c.Config)
	ctx, cancel := context.WithCancel(context.Background())
	defer cancel()
	util.SignalListener(ctx, cancel)

	err = agt.Run(ctx)
	if err != nil {
		c.Log.Errorf("agent crashed: %v", err)
		return 1
	}

	c.Log.Infof("Agent stopped gracefully")
	return 0
}

func (*RunCLI) Synopsis() string {
	return "Runs the agent"
}

func parseFile(filePath string) (*runConfig, error) {
	c := &runConfig{}

	// Return a friendly error if the file is missing
	if _, err := os.Stat(filePath); os.IsNotExist(err) {
		msg := "could not find config file %s: please use the -config flag"
		p, err := filepath.Abs(filePath)
		if err != nil {
			p = filePath
			msg = "could not determine CWD; config file not found at %s: use -config"
		}
		return nil, fmt.Errorf(msg, p)
	}

	data, err := ioutil.ReadFile(filePath)
	if err != nil {
		return nil, err
	}
	hclTree, err := hcl.Parse(string(data))
	if err != nil {
		return nil, err
	}
	if err := hcl.DecodeObject(&c, hclTree); err != nil {
		return nil, err
	}

	return c, nil
}

func parseFlags(args []string) (*runConfig, error) {
	flags := flag.NewFlagSet("run", flag.ContinueOnError)
	c := &runConfig{}

	flags.StringVar(&c.AgentConfig.ServerAddress, "serverAddress", "", "IP address or DNS name of the SPIRE server")
	flags.IntVar(&c.AgentConfig.ServerPort, "serverPort", 0, "Port number of the SPIRE server")
	flags.StringVar(&c.AgentConfig.TrustDomain, "trustDomain", "", "The trust domain that this agent belongs to")
	flags.StringVar(&c.AgentConfig.TrustBundlePath, "trustBundle", "", "Path to the SPIRE server CA bundle")
	flags.StringVar(&c.AgentConfig.JoinToken, "joinToken", "", "An optional token which has been generated by the SPIRE server")
	flags.StringVar(&c.AgentConfig.SocketPath, "socketPath", "", "Location to bind the workload API socket")
	flags.StringVar(&c.AgentConfig.DataDir, "dataDir", "", "A directory the agent can use for its runtime data")
	flags.StringVar(&c.AgentConfig.LogFile, "logFile", "", "File to write logs to")
	flags.StringVar(&c.AgentConfig.LogLevel, "logLevel", "", "DEBUG, INFO, WARN or ERROR")

	flags.StringVar(&c.AgentConfig.ConfigPath, "config", defaultConfigPath, "Path to a SPIRE config file")
	flags.StringVar(&c.AgentConfig.Umask, "umask", "", "Umask value to use for new files")

	err := flags.Parse(args)
	if err != nil {
		return nil, err
	}

	return c, nil
}

func mergeConfigs(c *agentConfig, fileConfig, cliConfig *runConfig) error {
	// CLI > File, merge fileConfig first
	err := mergeConfig(c, fileConfig)
	if err != nil {
		return err
	}

	return mergeConfig(c, cliConfig)
}

func mergeConfig(orig *agentConfig, cmd *runConfig) error {
	if cmd.AgentConfig.ServerAddress != "" {
		_, port, _ := net.SplitHostPort(orig.ServerAddress)
		orig.ServerAddress = net.JoinHostPort(cmd.AgentConfig.ServerAddress, port)
	}

	if cmd.AgentConfig.ServerPort != 0 {
		host, _, _ := net.SplitHostPort(orig.ServerAddress)
		orig.ServerAddress = net.JoinHostPort(host, strconv.Itoa(cmd.AgentConfig.ServerPort))
	}

	if cmd.AgentConfig.TrustDomain != "" {
		trustDomain, err := idutil.ParseSpiffeID("spiffe://"+cmd.AgentConfig.TrustDomain, idutil.AllowAnyTrustDomain())
		if err != nil {
			return err
		}
		orig.TrustDomain = *trustDomain
	}

	// Parse trust bundle
	if cmd.AgentConfig.TrustBundlePath != "" {
		bundle, err := parseTrustBundle(cmd.AgentConfig.TrustBundlePath)
		if err != nil {
			return fmt.Errorf("Error parsing trust bundle: %s", err)
		}

		orig.TrustBundle = bundle
	}

	if cmd.AgentConfig.JoinToken != "" {
		orig.JoinToken = cmd.AgentConfig.JoinToken
	}

	if cmd.AgentConfig.SocketPath != "" {
		orig.BindAddress.Name = cmd.AgentConfig.SocketPath
	}

	if cmd.AgentConfig.DataDir != "" {
		orig.DataDir = cmd.AgentConfig.DataDir
	}

	if cmd.AgentConfig.EnableSDS {
		orig.EnableSDS = cmd.AgentConfig.EnableSDS
	}

	// Handle log file and level
	if cmd.AgentConfig.LogFile != "" || cmd.AgentConfig.LogLevel != "" {
		logLevel := defaultLogLevel
		if cmd.AgentConfig.LogLevel != "" {
			logLevel = cmd.AgentConfig.LogLevel
		}

		logger, err := log.NewLogger(logLevel, cmd.AgentConfig.LogFile)
		if err != nil {
			return fmt.Errorf("Could not open log file %s: %s", cmd.AgentConfig.LogFile, err)
		}

		orig.Log = logger
	}

	if cmd.AgentConfig.Umask != "" {
		umask, err := strconv.ParseInt(cmd.AgentConfig.Umask, 0, 0)
		if err != nil {
			return fmt.Errorf("Could not parse umask %s: %s", cmd.AgentConfig.Umask, err)
		}
		orig.umask = int(umask)
	}

	if cmd.AgentConfig.ProfilingEnabled {
		orig.ProfilingEnabled = cmd.AgentConfig.ProfilingEnabled
	}

	if orig.ProfilingEnabled {
		if cmd.AgentConfig.ProfilingPort > 0 {
			orig.ProfilingPort = cmd.AgentConfig.ProfilingPort
		}

		if cmd.AgentConfig.ProfilingFreq > 0 {
			orig.ProfilingFreq = cmd.AgentConfig.ProfilingFreq
		}

		if len(cmd.AgentConfig.ProfilingNames) > 0 {
			orig.ProfilingNames = cmd.AgentConfig.ProfilingNames
		}
	}
	return nil
}

func validateConfig(c *agentConfig) error {
	host, port, _ := net.SplitHostPort(c.ServerAddress)
	if host == "" {
		return errors.New("ServerAddress is required")
	}

	if port == "" {
		return errors.New("ServerPort is required")
	}

	if c.TrustDomain.String() == "" {
		return errors.New("TrustDomain is required")
	}

	if c.TrustBundle == nil {
		return errors.New("TrustBundle is required")
	}

	return nil
}

func newDefaultConfig() *agentConfig {
	bindAddr := &net.UnixAddr{Name: defaultSocketPath, Net: "unix"}

	// log.NewLogger() cannot return error when using STDOUT
	logger, _ := log.NewLogger(defaultLogLevel, "")

	return &agentConfig{
		Config: agent.Config{
			BindAddress: bindAddr,
			DataDir:     defaultDataDir,
			Log:         logger,
		},
		umask: -1,
	}
}

func parseTrustBundle(path string) ([]*x509.Certificate, error) {
	pemData, err := ioutil.ReadFile(path)
	if err != nil {
		return nil, err
	}

	var data []byte
	for len(pemData) > 1 {
		var block *pem.Block
		block, pemData = pem.Decode(pemData)
		if block == nil && len(data) < 1 {
			return nil, errors.New("no certificates found")
		}

		if block == nil {
			return nil, errors.New("encountered unknown data in trust bundle")
		}

		if block.Type != "CERTIFICATE" {
			return nil, fmt.Errorf("non-certificate type %v found in trust bundle", block.Type)
		}

		data = append(data, block.Bytes...)
	}

	bundle, err := x509.ParseCertificates(data)
	if err != nil {
		return nil, fmt.Errorf("parse certificates from %v, %v", path, err)
	}

	return bundle, nil
}
