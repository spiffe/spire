# This is the SPIRE Server configuration file including all possible configuration
# options.

# server: Contains core configuration parameters.
server {
    # admin_ids: SPIFFE IDs that, when present in a caller's X509-SVID, grant
    # that caller admin privileges. The admin IDs must reside in the server
    # trust domain or a federated one, and need not have a corresponding
    # admin registration entry with the server.
    # admin_ids = ["spiffe://example.org/my/admin"]

    # bind_address: IP address or DNS name of the SPIRE server.
    # Default: 0.0.0.0.
    bind_address = "127.0.0.1"

    # bind_port: HTTP Port number of the SPIRE server. Default: 8081.
    bind_port = "8081"

    # ca_key_type: The key type used for the server CA (both X509 and JWT),
    # <rsa-2048|rsa-4096|ec-p256|ec-p384>. Default: ec-p256.
    # The JWT key type can be overridden by jwt_key_type.
    # ca_key_type = "ec-p256"

    # ca_subject: The Subject that CA certificates should use.
    ca_subject {
        # country: Array of Country values.
        country = ["US"]

        # organization: Array of Organization values.
        organization = ["SPIFFE"]

        # common_name: The CommonName value.
        common_name = ""
    }

    # ca_ttl: The default CA/signing key TTL. Default: 24h.
    # ca_ttl = "24h"

    # data_dir: A directory the server can use for its runtime.
    data_dir = "./.data"

    # federation: Use this to configure the bundle endpoint provided by this server
    # and/or the bundle endpoints to federate with.
    federation {
        # bundle_endpoint: Configuration for this server's bundle endpoint.
        bundle_endpoint {
            # address: IP address where this server will listen for HTTP requests.
            address = "0.0.0.0"

            # port: TCP port number where this server will listen for HTTP requests.
            port = 8443

            # refresh_hint: The refresh hint advertised in the bundles fetched from this endpoint
            # Default: 5 minutes.
            refresh_hint = "5m"

            # profile "https_web": Configuration for the https_web profile.
            profile "https_web" {
                # acme: Automated Certificate Management Environment configuration section.
                acme {
                    # directory_url: Directory endpoint. Default: https://acme-v02.api.letsencrypt.org/directory
                    # directory_url = "https://acme-v02.api.letsencrypt.org/directory"

                    # domain_name: Domain for which the certificate manager tries to retrieve
                    # new certificates.
                    domain_name = "example.org"

                    # email: Contact email address. This is used by CAs, such as Let's Encrypt,
                    # to notify about problems with issued certificates.
                    email = "some@mail.com"

                    # tos_accepted: ACME Terms of Service acceptance. If not true, and the
                    # provider requires acceptance, then certificate retrieval will fail.
                    # Default: false.
                    # tos_accepted = false
                }

                # Use certificate and key from disk
                # serving_cert_file = {
                    # cert_file_path= "conf/server/bundleendpoint.crt"
                    # key_file_path = "conf/server/bundleendpoint.key"
                    # file_sync_interval = "1h"
                # }
	    }

            # profile "https_spiffe": Configuration for the https_spiffe profile.
	    # profile "https_spiffe" { }
        }

        # federates_with "<trust domain>": configures the address of a bundle endpoint used to
        # get a trust bundle for "<trust domain>". This section must be repeated for each
        # federated trust domain.
        federates_with "domain1.test" {
            # bundle_endpoint_url: Bundle endpoint URL. Default: "".
            bundle_endpoint_url = "https://example.com/global/bundle.json"

            # bundle_endpoint_profile "<https_web|https_spiffe>". Endpoint profile.
            # bundle_endpoint_profile "https_spiffe": Configuration for the https_spiffe profile.
            bundle_endpoint_profile "https_spiffe" {
                # endpoint_spiffe_id: Expected SPIFFE ID of the bundle endpoint server. This
                # must be specified when using the https_spiffe profile. It's not valid in
                # the https_web profile.
                endpoint_spiffe_id = "spiffe://example.com/spire/server"
            }

            # bundle_endpoint_profile "https_web": Configuration for the https_web profile.
            # bundle_endpoint_profile "https_web" {}
        }
    }

    # disable_jwt_svids: If true, disables JWT-SVID profile.
    # disable_jwt_svids = true

    # jwt_key_type: The key type used for the server CA (JWT),
    # <rsa-2048|rsa-4096|ec-p256|ec-p384>. Default: the value of
    # ca_key_type or ec-p256 if not defined.
    # jwt_key_type = "ec-p256"

    # jwt_issuer: The issuer claim used when minting JWT-SVIDs.
    # jwt_issuer = ""

    # log_file: File to write logs to
    #
    # If set, spire-server will spawn a handler to reopen the file upon receipt
    # of SIGUSR2 to support log rotation. To use logrotate without lossy
    # copytruncate option, users MUST add a postrotate script to the logrotate
    # configuration to send the SIGUSR2 signal to the spire-server process.
    #
    # Minimal example of logrotate.conf:
    #
    # /path/to/spire-server.log {
    #     rotate 7
    #     postrotate
    #         killall -USR2 spire-server
    #     endscript
    # }
    #
    # log_file = ""

    # log_level: Sets the logging level <DEBUG|INFO|WARN|ERROR>. Default: INFO.
    # log_level = "INFO"

    # Format of logs, <text|json>. Default: text.
    # log_format = "text"

    # log_source_location: whether to include source file, line number, and
    # function name in each log line. Default: false.
    # log_source_location = true

    # ratelimit: Holds rate limiting configurations.
    # ratelimit = {
    #     # Controls whether node attestation is rate limited to one
    #     # attempt per-second per-IP. Default: true.
    #     attestation = true

    #     # Controls whether X509 and JWT signing are rate limited to 500
    #     # requests per-second per-IP (separately). Default: true.
    #     signing = true
    # }

    # socket_path: Path to bind the SPIRE Server API socket to.
    # Default: /tmp/spire-server/private/api.sock.
    # socket_path = "/tmp/spire-server/private/api.sock"

    # max_attested_node_info_staleness: How long to trust stale cache information
    # about attested nodes.
    # Default: 0s
    # max_attested_node_info_staleness = "0s"

    # agent_ttl: The TTL to use for agent SVIDs, and thus the longest an
    # agent can survive without checking back in to the server.
    # Default: Value of default_x509_svid_ttl
    # agent_ttl = "72h"

    # default_x509_svid_ttl: The default X509-SVID TTL. Default: 1h.
    # default_x509_svid_ttl = "1h"

    # default_jwt_svid_ttl: The default JWT-SVID TTL. Default: 5m.
    # default_jwt_svid_ttl = "5m"

    # trust_domain: The trust domain that this server belongs to.
    trust_domain = "example.org"

    # audit_log_enabled: If true, enables audit logging.
    # audit_log_enabled = false

    # experimental: The experimental options that are subject to change or removal
    # experimental {
    #     # cache_reload_interval: The amount of time between two reloads of
    #     # the in-memory entry cache. Default: 5s.
    #     cache_reload_interval = "5s"
    #
    #     # auth_opa_policy_engine: The auth OPA policy engine used for authorization
    #     # decision.
    #     # For more details, refer to doc/authorization_policy_engine.md
    #     auth_opa_policy_engine {
    #         # Indicates that OPA provided through local files be used to
    #         # instantiate the auth policy engine
    #         local {
    #             # Path to the rego file
    #             rego_path = "./conf/server/policy.rego"
    #             # Path to the policy data bindings (JSON data file)
    #             policy_data_path = "./conf/server/policy_data.json"
    #         }
    #     }
    #     # named_pipe_name: Pipe name of the SPIRE Server API named pipe (Windows only).
    #     # Default: \spire-server\private\api
    #     named_pipe_name = "\\spire-server\\private\\api"
    # }
}

# plugins: Contains the configuration for each plugin.
# Each nested object has the following format:
#
#     PluginType "plugin_name" {
#
#         # plugin_cmd: Path to the plugin implementation binary (optional, not
#         # needed for built-ins)
#         plugin_cmd = <string>
#
#         # plugin_checksum: An optional sha256 of the plugin binary (optional,
#         # not needed for built-ins)
#         plugin_checksum = <string>
#
#         # plugin_data: Plugin-specific data (mutually exclusive with plugin_data_file)
#         plugin_data {
#             ...configuration options...
#         }
#
#         # plugin_data_file: Path to file with plugin-specific data (mutually exclusive with plugin_data)
#         plugin_data_file = <string>
#
#         # enabled: Enable or disable the plugin (enabled by default)
#         enabled = [true | false]
#     }
plugins {
    # CredentialComposer "uniqueid": Adds an x509UniqueIdentifier name, derived
    # from the SPIFFE ID, to the subject of workload X509-SVIDs.
    # CredentialComposer "uniqueid" {}

    # DataStore "sql": SQL database storage for SQLite, PostgreSQL and MySQL
    # databases for the SPIRE datastore.
    DataStore "sql" {
        plugin_data {
            # database_type: database type, <sqlite3|postgres|mysql>
            database_type = "sqlite3"

            # database_type "<aws_postgres|aws_mysql>". Database type with IAM
            # authentication.
            # database_type "aws_postgres" {
            #    region: AWS Region to use.
            #    region = ""
            # }

            # database_type "aws_mysql" {
            #    region: AWS Region to use.
            #    region = ""
            # }

            # connection_string: database specific connection string. The format
            # depends on the value specified for database_type.
            connection_string = "./.data/datastore.sqlite3"

            # ro_connection_string: read only connection. The formatted string
            # takes the same form as connection_string. This option is not
            # applicable for SQLite3.
            # ro_connection_string = ""

            # root_ca_path: Path to Root CA bundle (MySQL only)
            # root_ca_path = ""

            # client_cert_path: Path to client certificate (MySQL only)
            # client_cert_path = ""

            # client_key_path: Path to private key for client certificate (MySQL only)
            # client_key_path = ""

            # max_open_conns: The maximum number of open db connections. Default: 100.
            # max_open_conns = 100

            # max_idle_conns: The maximum number of idle connections in the pool. Default: 2.
            # max_idle_conns = 2

            # conn_max_lifetime: The maximum amount of time a connection may be
            # reused. Default: unlimited.
            # conn_max_lifetime = 0

            # disable_migration: True to disable auto-migration functionality. Use
            # of this flag allows finer control over when datastore migrations
            # occur and coordination of the migration of a datastore shared with a
            # SPIRE Server cluster. Only available for databases from SPIRE Code
            # version 0.9.0 or later.
            # disable_migration = false
        }
    }

    # KeyManager  "aws_kms": A key manager for signing SVIDs which only generates and stores keys in AWS KMS
    # KeyManager "aws_kms" {
    #     plugin_data {
    #         region: AWS Region to use.
    #         region = ""
    #
    #         key_identifier_file: A file path location where information about generated keys will be persisted
    #         key_identifier_file = "./file_path"
    #         
    #         # key_tags: A list of custom tags to add to KMS keys created
    #         # key_tags {
    #         #     Environment = "production"
    #         #     Team        = "security"
    #         #     Component   = "spire"
    #         # }
    #     }
    # }

    # KeyManager "disk": A disk-based key manager for signing SVIDs.
    # KeyManager "disk" {
    #     plugin_data {
    #         # keys_path: Path to the keys file on disk.
    #         # keys_path = "/opt/spire/data/server/keys.json"
    #     }
    # }

    # KeyManager "gcp_kms": A key manager for signing SVIDs which generates
    # and stores keys in Google Cloud KMS.
    # KeyManager "gcp_kms" {
    #    plugin_data = {
    #         # key_identifier_file: A file path location where information about
    #         # generated keys will be persisted.
    #         key_identifier_file = "./file_path"
    #
    #         # key_policy_file: A file path location to a custom IAM Policy (v3)
    #         # in JSON format to be attached to created CryptoKeys.
    #         # key_policy_file = "custom-gcp-kms-policy.json"
    #
    #         # key_ring: Resource ID of the key ring where the keys managed by this
    #         # plugin reside.
    #         # key_ring = "projects/project/locations/location/keyRings/key-ring"
    #
    #         # service_account_file: Path to the service account file used to
    #         # authenticate with the Google Cloud KMS API.
    #         # service_account_file = ""
    #    }
    # }

    # KeyManager "azure_key_vault": A key manager for signing SVIDs which generates
    # and stores keys in Microsoft Azure Key Vault.
    # KeyManager "azure_key_vault" {
    #    plugin_data = {
    #         # key_identifier_file: A file path location where information about
    #         # generated keys will be persisted.
    #         key_identifier_file = "./file_path"

    #         # key_vault_uri: The key vault URI where the keys managed by this
    #         # plugin reside.
    #         # key_vault_uri = "https://spire-server.vault.azure.net/"
    #
    #         # use_msi: Deprecated and will be removed in a future release; will be used implicitly if other mechanisms to authenticate fail.
    #         # whether to use MSI to authenticate to
    #         # Azure Key Vault. Mutually exclusive with
    #         # tenant_id, subscription_id, app_id, and app_secret.
    #         # use_msi = false

    #         # subscription_id: The subscription the tenant resides
    #         # in. Used with tenant_id, app_id and app_secret.
    #         # Mutually exclusive with use_msi.
    #         # subscription_id = ""

    #         # app_id: The application id. Used with tenant_id, subscription_id
    #         # and app_secret.
    #         # Mutually exclusive with use_msi.
    #         # app_id = ""

    #         # app_secret: The application secret. Used with
    #         # tenant_id, subscription_id and app_id.
    #         # Mutually exclusive with use_msi.
    #         # app_secret = ""

    #         # tenant_id: The tenant id. Used with
    #         # app_secret, subscription_id and app_id.
    #         # Mutually exclusive with use_msi.
    #         # tenant_id = ""
    #    }
    # }

    # KeyManager "memory": A key manager for signing SVIDs which only stores
    # keys in memory and does not actually persist them anywhere.
    KeyManager "memory" {
        plugin_data {}
    }

    # NodeAttestor "aws_iid": A node attestor which attests agent identity
    # using an AWS Instance Identity Document.
    # NodeAttestor "aws_iid" {
    #     plugin_data {
    #         # access_key_id: AWS access key id. Default: value of
    #         # AWS_ACCESS_KEY_ID environment variable.
    #         # access_key_id = ""

    #         # secret_access_key: AWS secret access key. Default: value of
    #         # AWS_SECRET_ACCESS_KEY environment variable.
    #         # secret_access_key = ""

    #         # skip_block_device: Skip anti-tampering mechanism which checks to
    #         # make sure that the underlying root volume has not been detached
    #         # prior to attestation. Default: false
    #         # skip_block_device = false

    #         # verify_organization: Verify if the attesting node's account ID is part of the configured AWS Organization.
    #         # Make sure that the IAM role formed from the configuration below (e.g., "arn:aws:iam::management_account_id:role/assume_org_role")
    #         # can be assumed by the spire-server.
    #         verify_organization {
    #             # management_account_id: Management account ID, also known as the root account,
    #             # value will be the respective organization's management/root account ID. It's a required parameter.
    #             # management_account_id = ""

    #             # management_account_region: Management account region, specifies the region
    #             # in which the management account is hosted. It's an optional parameter.
    #             # Default: us-west-2
    #             # management_account_region = ""

    #             # assume_org_role: Assume org role, specifies the role name present in the management
    #             # account. It's a required parameter.
    #             # assume_org_role = ""

    #             # org_account_map_ttl: Org account map TTL, specifies the interval for retrieving the list of accounts present in the Organization.
    #             # It's an optional parameter. If specified, it should be greater than or equal to the duration of 1m (minute).
    #             # Default: 3m.
    #             # org_account_map_ttl = ""
    #         }
             
    #         # validate_eks_cluster_membership: Validate if the attesting node is part of an EKS cluster.
    #         validate_eks_cluster_membership { 
    #             # eks_cluster_names: A list of EKS cluster names that the attesting node should be part of.
    #             # If specified, the attestation will be rejected if the attesting node is not part of any of the specified clusters.
    #             # eks_cluster_names = ["test-cluster"] 
    #         }
    #     }
    # }

    # NodeAttestor "azure_msi": A node attestor which attests agent identity
    # using an Azure MSI token.
    # NodeAttestor "azure_msi" {
    #     plugin_data {
    #         # tenants: A map of tenants, keyed by tenant ID, that are
    #         # authorized for attestation. Tokens for unspecified tenants are
    #         # rejected.
    #         # tenants = {
    #             # "<tenant ID>" = {
    #                 # resource_id: The resource ID (or audience) for the
    #                 # tenant's MSI token. Tokens for a different resource
    #                 # ID are rejected. Default: https://management.azure.com/
    #                 # resource_id = "https://management.azure.com/"

    #                 # use_msi: Deprecated and will be removed in a future release; will be used implicitly if other mechanisms to authenticate fail.
    #                 # whether to use MSI to authenticate to
    #                 # Azure services. Mutually exclusive with
    #                 # subscription_id, app_id, and app_secret.
    #                 # use_msi = false

    #                 # subscription_id: The subscription the tenant resides
    #                 # in. Used with app_id and app_secret to grant access to
    #                 # the Azure APIs to resolve selectors. Mutually exclusive
    #                 # with use_msi.
    #                 # subscription_id = ""

    #                 # app_id: The application id. Used with subscription_id
    #                 # and app_secret to grant access to the Azure APIs to
    #                 # resolve selectors. Mutually exclusive with use_msi.
    #                 # app_id = ""

    #                 # app_secret: The application secret. Used with
    #                 # subscription_id and app_id to grant access to the Azure
    #                 # APIs to resolve selectors. Mutually exclusive with
    #                 # use_msi.
    #                 # app_secret = ""
    #             # }
    #         # }
    #       # agent_path_template: A URL path portion format of Agent's SPIFFE ID.
    #       # Describe in text/template format.
    #       # agent_path_template = ""
    #     }
    # }

    # NodeAttestor "gcp_iit": A node attestor which attests agent identity
    # using a GCP Instance Identity Token.
    # NodeAttestor "gcp_iit" {
    #     plugin_data {
    #         # projectid_allow_list: List of allowed ProjectIDs from which
    #         # nodes can be attested.
    #         # projectid_allow_list = ["project-123"]

    #         # use_instance_metadata: If true, instance metadata is fetched from
    #         # the Google Compute Engine API and used to augment the node
    #         # selectors produced by the plugin. Default: false.
    #         # use_instance_metadata = false

    #         # service_account_file: Path to the service account file used to
    #         # authenticate with the Google Compute Engine API.
    #         # service_account_file = ""

    #         # allowed_label_keys: Instance label keys considered for selectors.
    #         # allowed_label_keys = []

    #         # allowed_metadata_keys: Instance metadata keys considered for
    #         # selectors.
    #         # allowed_metadata_keys = []

    #         # max_metadata_value_size: Sets the maximum metadata value size
    #         # considered by the plugin for selectors. Default: 128.
    #         # max_metadata_value_size = 128
    #     }
    # }

    # NodeAttestor "join_token": A node attestor which validates agents
    # attesting with server-generated join tokens.
    NodeAttestor "join_token" {
        plugin_data {}
    }

    # NodeAttestor "k8s_psat": A node attestor which attests agent identity
    # using a Kubernetes Projected Service Account token.
    # NodeAttestor "k8s_psat" {
    #     plugin_data {
    #         # clusters: A map of clusters, keyed by an arbitrary ID, that are
    #         # authorized for attestation.
    #         # clusters = {
    #             # "<arbitrary ID>" = {
    #                 # service_account_allow_list: A list of service account names,
    #                 # qualified by namespace (for example, "default:blog" or
    #                 # "production:web") to allow for node attestation. Attestation
    #                 # will be rejected for tokens bound to service accounts that
    #                 # aren't in the allow list.
    #                 # service_account_allow_list = []

    #                 # audience: Audience for token validation. If it is set to an
    #                 # empty array ([]), Kubernetes API server audience is used.
    #                 # Default: ["spire-server"].
    #                 # audience = ["spire-server"]

    #                 # kube_config_file: Path to a k8s configuration file for API
    #                 # Server authentication. A kubernetes configuration file must
    #                 # be specified if SPIRE server runs outside of the k8s cluster.
    #                 # If empty, SPIRE server is assumed to be running inside the
    #                 # cluster and in-cluster configuration is used.	Default: "".
    #                 # kube_config_file = ""

    #                 # allowed_node_label_keys: Node label keys considered for
    #                 # selectors.
    #                 # allowed_node_label_keys = []

    #                 # allowed_pod_label_keys: Pod label keys considered for selectors.
    #                 # allowed_pod_label_keys = []
    #             # }
    #         # }
    #     }
    # }

    # NodeAttestor "sshpop": A node attestor which attests agent identity
    # using an existing ssh certificate.
    # NodeAttestor "sshpop" {
    #     plugin_data {
    #         # cert_authorities: A list of trusted CAs in ssh authorized_keys format.
    #         # cert_authorities = []

    #         # cert_authorities_path: A file that contains a list of trusted CAs in
    #         # ssh authorized_keys format.
    #         # cert_authorities_path = ""
    #
    #         # canonical_domain: A domain suffix for validating the hostname against
    #         # the certificate's valid principals.
    #         # canonical_domain = ""
    #
    #         # agent_path_template: A URL path portion format of Agent's SPIFFE ID.
    #         # Describe in text/template format.
    #         # agent_path_template = ""
    #     }
    # }

    # NodeAttestor "x509pop": A node attestor which attests agent identity
    # using an existing X.509 certificate.
    # NodeAttestor "x509pop" {
    #     plugin_data {
    #         # ca_bundle_path: The path to the trusted CA bundle on disk. The file
    #         # must contain one or more PEM blocks forming the set of trusted root
    #         # CA's for chain-of-trust verification. The file must contain one
    #         # or more PEM blocks forming the set of trusted roots. If the CA
    #         # certificates are in more than one file, use `ca_bundle_paths`
    #         # instead.
    #         # ca_bundle_path = ""
    #
    #         # ca_bundle_paths: A list of paths to trusted CA bundles on disk. The files
    #         # must contain one or more PEM blocks forming the set of trusted root
    #         # CA's for chain-of-trust verification.
    #         # ca_bundle_paths = []
    #
    #         # agent_path_template: A URL path portion format of Agent's SPIFFE ID.
    #         # Describe in text/template format.
    #         # agent_path_template = ""
    #     }
    # }

    # NodeAttestor "tpm_devid": A node attestor which attests agent identities
    # that own a TPM and have been provisioned with a LDevID certificate.
    # NodeAttestor "tpm_devid" {
    #     plugin_data {
    #         # devid_ca_path: The path to the trusted CA certificate(s) on disk
    #         # to use for DevID validation. The file must contain one or more
    #         # PEM blocks forming the set of trusted root CA's for
    #         # chain-of-trust verification.
    #         # devid_ca_path = "devid-ca.pem"
    #
    #         # endorsement_ca_path: The path to the trusted manufacturer CA
    #         # certificate(s) on disk. The file must contain one or more PEM
    #         # blocks forming the set of trusted manufacturer CA's for
    #         # chain-of-trust verification.
    #         # endorsement_ca_path = "endorsement-ca.pem"
    #     }
    # }

    # Notifier "gcs_bundle": A notifier that pushes the latest trust bundle
    # contents into an object in Google Cloud Storage.
    # Notifier "gcs_bundle" {
    #     plugin_data {
    #         # bucket: The bucket containing the object.
    #         # bucket = ""

    #         # object_path: The path to the object within the bucket.
    #         # object_path = ""

    #         # service_account_file: Path to the service account credentials file.
    #         # service_account_file = ""
    #     }
    # }

    # Notifier "k8sbundle": A notifier that pushes the latest trust bundle
    # contents into a Kubernetes ConfigMap.
    # Notifier "k8sbundle" {
    #     plugin_data {
    #         # namespace: The namespace containing the ConfigMap. Default: spire.
    #         # namespace = "spire"

    #         # config_map: The name of the ConfigMap. Default: spire-bundle.
    #         # config_map = "spire-bundle"

    #         # config_map_key: The key within the ConfigMap for the bundle. Default: bundle.crt.
    #         # config_map_key = "bundle.crt"

    #         # kube_config_file_path: The path on disk to the kubeconfig
    #         # containing configuration to enable interaction with the
    #         # Kubernetes API server. If unset, it is assumed the notifier
    #         # is in-cluster and in-cluster credentials will be used.
    #         # Required for remote clusters.
    #         # kube_config_file_path = ""

    #         # clusters: Extra remote clusters.
    #         # clusters = [
    #         # {
    #         #      namespace = "infra"
    #         #      config_map = "agents"
    #         #      config_map_key = "bootstrap.crt"
    #         #      kube_config_file_path = "/path/to/kubeconfig"
    #         # }
    #         # ]
    #     }
    # }

    # UpstreamAuthority "disk": Uses a CA loaded from disk to sign SPIRE server
    # intermediate certificates.
    UpstreamAuthority "disk" {
        plugin_data {
            # key_file_path: Path to the "upstream" CA key file. Key files must
            # contain a single PEM encoded key. The supported key types are EC
            # (ASN.1 or PKCS8 encoded) or RSA (PKCS1 or PKCS8 encoded).
            key_file_path = "./conf/server/dummy_upstream_ca.key"

            # cert_file_path: If SPIRE is using a self-signed CA, cert_file_path
            # should specify the path to a single PEM encoded certificate
            # representing the upstream CA certificate. If not self-signed,
            # cert_file_path should specify the path to a file that must contain
            # one or more certificates necessary to establish a valid certificate
            # chain up the root certificates defined in bundle_file_path.
            cert_file_path = "./conf/server/dummy_upstream_ca.crt"

            # bundle_file_path: If SPIRE is using a self-signed CA, bundle_file_path
            # can be left unset. If not self-signed, then bundle_file_path should
            # be the path to a file that must contain one or more certificates
            # representing the upstream root certificates and the file at
            # cert_file_path contains one or more certificates necessary to chain up
            # the root certificates in bundle_file_path (where the first
            # certificate in cert_file_path is the upstream CA certificate).
            # bundle_file_path = ""
        }
    }

    # UpstreamAuthority "aws_pca": Uses a Private Certificate Authority from
    # AWS Certificate Manager to sign SPIRE server intermediate certificates.
    # UpstreamAuthority "aws_pca" {
    #     plugin_data {
    #         # region: AWS Region to use.
    #         # region = ""

    #         # certificate_authority_arn: ARN of the "upstream" CA certificate.
    #         # certificate_authority_arn = ""

    #         # ca_signing_template_arn (Optional): ARN of the signing template
    #         # to use for the server's CA. Defaults to a signing template for
    #         # end-entity certificates only.
    #         # ca_signing_template_arn = ""


    #         # signing_algorithm (Optional): Signing algorithm to use for the
    #         # server's CA. Defaults to the CA's default.
    #         # signing_algorithm = ""

    #         # assume_role_arn (Optional): ARN of an IAM role to assume.
    #         # assume_role_arn = ""

    #         # endpoint (Optional): Endpoint as hostname or fully-qualified
    #         # URI that overrides the default endpoint.
    #         # endpoint = ""
    #     }
    # }

    # UpstreamAuthority "awssecret": Uses a CA loaded from AWS SecretsManager
    # to sign SPIRE server intermediate certificates.
    # UpstreamAuthority "awssecret" {
    #     plugin_data {
    #         # region: AWS Region that the AWS Secrets Manager is running in.
    #         # region = ""

    #         # cert_file_arn: ARN of the "upstream" CA certificate.
    #         # cert_file_arn = ""

    #         # key_file_arn: ARN of the "upstream" CA key file.
    #         # key_file_arn = ""

    #         # access_key_id: AWS access key ID.
    #         # access_key_id = ""

    #         # secret_access_key: AWS secret access key.
    #         # secret_access_key = ""

    #         # secret_token: AWS secret token.
    #         # secret_token = ""

    #         # assume_role_arn: ARN of role to assume.
    #         # assume_role_arn = ""
    #     }
    # }

    # UpstreamAuthority "gcp_cas": Uses a Certificate Authority Service of
    # Google Cloud Platform to sign SPIRE server intermediate certificates.
    # UpstreamAuthority "gcp_cas" {
    #     plugin_data {
    #         root_cert_spec {
    #             # All fields are required
    #             # Project name + region name is used to retrieve a set of CAs
    #             project_name = ""
    #             region_name = ""
    #             # label key + label value is used to filter and select a subset of CAs
    #             label_key = ""
    #             label_value = ""
    #         }
    #     }
    # }

    # UpstreamAuthority "vault": Uses a PKI Secret Engine from HashiCorp Vault
    # to sign SPIRE server intermediate certificates.
    # UpstreamAuthority "vault" {
    #     plugin_data {
    #         # vault_addr: The URL of the Vault server.
    #         # Default: ${VAULT_ADDR}.
    #         # vault_addr = ""

    #         # namespace: Name of the Vault namespace.
    #         # Default: ${VAULT_NAMESPACE}.
    #         # namespace = ""

    #         # pki_mount_point: Name of the mount point where PKI secret engine is mounted.
    #         # Default: pki.
    #         # pki_mount_point = ""

    #         # ca_cert_path: Path to a CA certificate file used to verify
    #         # the Vault server certificate. Only PEM format is supported.
    #         # Default: ${VAULT_CACERT}.
    #         # ca_cert_path = ""

    #         # insecure_skip_verify: If true, vault client accepts any server certificates.
    #         # Default: false.
    #         # insecure_skip_verify = false

    #         # cert_auth: Configuration for the Client Certificate authentication method.
    #         # cert_auth {
    #             # cert_auth_mount_point: Name of the mount point
    #             # where TLS certificate auth method is mounted. Default: cert.
    #             # cert_auth_mount_point = ""

    #             # cert_auth_role_name: Name of the Vault role
    #             # If given, the plugin authenticates against only the named role.
    #             # Default to trying all roles.
    #             # cert_auth_role_name = ""

    #             # client_cert_path: Path to a client certificate file.
    #             # Only PEM format is supported. Default: ${VAULT_CLIENT_CERT}.
    #             # client_cert_path = ""

    #             # client_key_path: Path to a client private key file.
    #             # Only PEM format is supported. Default: ${VAULT_CLIENT_KEY}.
    #             # client_key_path  = ""
    #         # }

    #         # token_auth: Configuration for the Token authentication method.
    #         # token_auth {
    #             # token: Token string to set into "X-Vault-Token" header.
    #             # Default: ${VAULT_TOKEN}.
    #             # token = ""
    #         # }

    #         # approle_auth: Configuration for the AppRole authentication method.
    #         # approle_auth {
    #             # approle_auth_mount_point: Name of the mount point
    #             # where the AppRole auth method is mounted. Default: approle.
    #             # approle_auth_mount_point = ""

    #             # approle_id: An identifier of AppRole. Default: ${VAULT_APPROLE_ID}.
    #             # approle_id = ""

    #             # approle_secret_id: A credential of AppRole. Default: ${VAULT_APPROLE_SECRET_ID}.
    #             # approle_secret_id = ""
    #         # }

    #         # k8s_auth: Configuration for the Kubernetes authentication method.
    #         # k8s_auth {
    #             # k8s_auth_mount_point: Name of the mount point
    #             # where the Kubernetes auth method is mounted. Default: kubernetes.
    #             # k8s_auth_mount_point = ""

    #             # k8s_auth_role_name: Name of the Vault role. The plugin authenticates against the named role
    #             # k8s_auth_role_name = ""

    #             # token_path: Path to the Kubernetes Service Account Token to use authentication with the Vault
    #             # Default: /var/run/secrets/kubernetes.io/serviceaccount/token
    #             # token_path = ""
    #         # }
    #     }
    # }

    # UpstreamAuthority "spire": Uses an upstream SPIRE server in the same
    # trust domain to obtain intermediate signing certificates for SPIRE server.
    # UpstreamAuthority "spire" {
    #     plugin_data {
    #         # server_address: IP address or DNS name of the upstream SPIRE server
    #         # in the same trust domain.
    #         # server_address = ""

    #         # server_port: Port number of the upstream SPIRE server in the same
    #         # trust domain.
    #         # server_port = ""

    #         # workload_api_socket: Path to the SPIRE Agent API socket (Unix only).
    #         # workload_api_socket = ""

    #         # experimental: The experimental options that are subject to change or removal.
    #         # experimental {
    #              # workload_api_named_pipe_name: Pipe name of the SPIRE Agent API named pipe (Windows only).
    #              # workload_api_named_pipe_name = ""
    #         # }
    #     }
    # }

    # UpstreamAuthority "cert-manager": Uses cert-manager in a target
    # Kubernetes cluster to sign SPIRE server intermediate certificates.
    # UpstreamAuthority "cert-manager" {
    #     plugin_data {
    #         # kube_config_file: Filepath to a kubeconfig to access the Kubernetes cluster. Empty path will attempt to use an in-cluster config.
    #         kube_config_file = "/etc/kubernetes/kubeconfig.yaml"

    #         # issuer_name: The issuer name to reference when creating CertificateRequests
    #         issuer_name = "spire-ca"
    #         # issuer_kind: The issuer kind to reference when creating CertificateRequests. Defaults to "Issuer" when empty.
    #         issuer_kind = "Issuer"
    #         # issuer_group: The issuer group to reference when creating CertificateRequests. Defaults to "cert-manager.io" when empty.
    #         issuer_group = "cert-manager.io"
    #         # namespace: The namespace to create CertificateRequests.
    #         namespace = "sandbox"
    #     }
    # }

    # UpstreamAuthority "ejbca": Uses a connected EJBCA to sign SPIRE server 
    # intermediate certificates
    UpstreamAuthority "ejbca" {
        plugin_data {
            # The hostname of the connected EJBCA server.  
            hostname = "ejbca.example.com"
            # (optional) The path to the CA certificate file used to validate the 
            # EJBCA server's certificate. Certificates must be in PEM format.
            ca_cert_path = "/path/to/ca_cert.pem"
            # The path to the client certificate (public key only) used 
            # to authenticate to EJBCA. Must be in PEM format.
            client_cert_path = "/path/to/client_cert.pem"
            # The path to the client key matching `client_cert` used to 
            # authenticate to EJBCA. Must be in PEM format.
            client_cert_key_path = "/path/to/client_key.pem"
            # The name of a CA in the connected EJBCA instance that will 
            # issue the intermediate signing certificates.
            ca_name = "Fake-Sub-CA"
            # The name of an end entity profile in the connected EJBCA 
            # instance that is configured to issue SPIFFE certificates.
            end_entity_profile_name = "fakeSpireIntermediateCAEEP"
            # The name of a certificate profile in the connected EJBCA instance 
            # that is configured to issue intermediate CA certificates.
            certificate_profile_name = "fakeSubCACP"
            # (optional) The name of the end entity, or configuration for how 
            # the EJBCA UpstreamAuthority should determine the end entity name. 
            end_entity_name = ""
            # (optional) An account binding ID in EJBCA to associate with issued certificates.
            account_binding_id = "abc123"
        }
    }


    # BundlePublisher "aws_s3": A bundle publisher that puts the current trust
    # bundle of the server in a designated Amazon S3 bucket, keeping it updated.
    # BundlePublisher "aws_s3" {
    #     plugin_data {
    #         # region: AWS region to store the trust bundle. Default: "".
    #         # region = "us-east-1"

    #         # access_key_id: AWS access key id. Default: value of
    #         # AWS_ACCESS_KEY_ID environment variable.
    #         # access_key_id = ""

    #         # secret_access_key: AWS secret access key. Default: value of
    #         # AWS_SECRET_ACCESS_KEY environment variable.
    #         # secret_access_key = ""

    #         # bucket: The Amazon S3 bucket name to which the trust bundle is uploaded. Default: "".
    #         # bucket = "spire-bundle-1"

    #         # object_key: The object key inside the bucket. Default: "".
    #         # object_key = "example.org"

    #         # format: Format in which the trust bundle is stored, <spiffe | jwks | pem>. Default: "".
    #         # format = "spiffe"
    #     }
    # }

    # BundlePublisher "aws_rolesanywhere_trustanchor": A bundle publisher that puts the current trust
    # bundle of the server in an AWS IAM Roles Anywhere trust anchor, keeping it updated.
    # BundlePublisher "aws_rolesanywhere_trustanchor" {
    #     plugin_data {
    #         # region: AWS region to store the trust bundle. Default: "".
    #         # region = "us-east-1"

    #         # access_key_id: AWS access key id. Default: value of
    #         # AWS_ACCESS_KEY_ID environment variable.
    #         # access_key_id = ""

    #         # secret_access_key: AWS secret access key. Default: value of
    #         # AWS_SECRET_ACCESS_KEY environment variable.
    #         # secret_access_key = ""

    #         # trust_anchor_id: The AWS IAM Roles Anywhere trust anchor id of the trust anchor to which to put the trust bundle. Default: "".
    #         # trust_anchor_id = "153d3e58-cab5-4a59-a0a1-3febad2937c4"
    #     }
    # }

    # BundlePublisher "k8s_configmap": A bundle publisher that puts the current trust
    # bundle of the server in a designated Kubernetes ConfigMap, keeping it updated.
    # BundlePublisher "k8s_configmap" {
    #     plugin_data {
    #         clusters = {
    #             "example-cluster-1" = {
    #                 configmap_name = "example.org"
    #                 configmap_key = "bundle"
    #                 namespace = "spire"
    #                 kubeconfig_path = "/file/path/cluster-1"
    #                 format = "spiffe"
    #             },
    #             "example-cluster-2" = {
    #                 configmap_name = "example.org"
    #                 configmap_key = "bundle"
    #                 namespace = "spire"
    #                 kubeconfig_path = "/file/path/cluster-2"
    #                 format = "pem"
    #             }
    #         }
    #     }
    # }
}

# telemetry: If telemetry is desired use this section to configure the
# available metrics collectors.
# telemetry {
#     Prometheus {
#         # host: Prometheus exporter listen address.
#         # host = ""

#         # port: Prometheus exporter listen port.
#         port = 9988
#     }

#     DogStatsd = [
#         # List of DogStatsd addresses.
#         { address = "localhost:8125" },
#         { address = "collector.example.org:1337" },
#     ]

#     Statsd = [
#         # List of Statsd addresses.
#         { address = "localhost:1337" },
#         { address = "collector.example.org:8125" },
#     ]

#     M3 = [
#         # List of M3 configurations.
#         { address = "localhost:9000" env = "dev" },
#         { address = "collector.example.org:9000" env = "prod" },
#     ]

#     InMem {
#     }
# }

# health_checks: If health checking is desired use this section to configure
# and expose an additional server endpoint for such purpose.
# health_checks {
#     # listener_enabled: Enables health checks endpoint.
#     listener_enabled = true

#     # bind_address: IP address or DNS name of the health checks endpoint. Default: localhost.
#     # bind_address = "localhost"

#     # bind_port: HTTP Port number of the health checks endpoint. Default: 80.
#     # bind_port = "80"

#     # live_path: HTTP resource path for checking server liveness. Default: /live.
#     # live_path = "/live"

#     # ready_path: HTTP resource path for checking server readiness. Default: /ready.
#     # ready_path = "/ready"
# }
