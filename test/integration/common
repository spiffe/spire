#!/bin/bash

norm=$(tput sgr0) || true
red=$(tput setaf 1) || true
green=$(tput setaf 2) || true
yellow=$(tput setaf 3) || true
bold=$(tput bold) || true

timestamp() {
    date -u "+[%Y-%m-%dT%H:%M:%SZ]"
}

log-info() {
    echo "${bold}$(timestamp) $*${norm}"
}

log-warn() {
    echo "${yellow}$(timestamp) $*${norm}"
}

log-success() {
    echo "${green}$(timestamp) $*${norm}"
}

log-debug() {
    echo "${norm}$(timestamp) $*"
}

fail-now() {
    echo "${red}$(timestamp) $*${norm}"
    exit 1
}

docker-up() {
    if [ $# -eq 0 ]; then
        log-debug "bringing up services..."
    else
        log-debug "bringing up $*..."
    fi
    docker-compose up -d "$@" || fail-now "failed to bring up services."
}

docker-stop() {
    if [ $# -eq 0 ]; then
        log-debug "stopping services..."
    else
        log-debug "stopping $*..."
    fi
    docker-compose stop "$@"
}

docker-down() {
    log-debug "bringing down services..."
    docker-compose down
}

docker-cleanup() {
    log-debug "cleaning up services..."
    docker-compose down -v --remove-orphans
}

fingerprint() {
	# calculate the SHA1 digest of the DER bytes of the certificate using the
	# "coreutils" output format (`-r`) to provide uniform output from
	# `openssl sha1` on macOS and linux.
	openssl x509 -in "$1" -outform DER | openssl sha1 -r | awk '{print $1}'
}

check-synced-entry() {
  # Check at most 30 times (with one second in between) that the agent has
  # successfully synced down the workload entry.
  MAXCHECKS=30
  CHECKINTERVAL=1
  for ((i=1;i<=MAXCHECKS;i++)); do
      log-info "checking for synced entry ($i of $MAXCHECKS max)..."
      docker-compose logs "$1"
      if docker-compose logs "$1" | grep "$2"; then
          return 0
      fi
      sleep "${CHECKINTERVAL}"
  done

  fail-now "timed out waiting for agent to sync down entry"
}

download-bin() {
    local bin_path=$1
    local bin_url=$2
    if [ ! -f "${bin_path}" ] ; then
        log-info "downloading $(basename ${bin_path}) from ${bin_url}..."
        curl -# -f -Lo "${bin_path}" "${bin_url}"
        chmod +x "${bin_path}"
    fi
}

download-kind() {
    KINDVERSION=v0.11.1
    KINDPATH=$(command -v kind || echo)
    UNAME=$(uname | awk '{print tolower($0)}')
    KINDURL="https://github.com/kubernetes-sigs/kind/releases/download/$KINDVERSION/kind-$UNAME-amd64"

    local kind_path=$1
    # Ensure kind exists at the expected version
    if [ -x "${KINDPATH}" ] && "${KINDPATH}" version | grep -q "${KINDVERSION}"; then
        ln -s "${KINDPATH}" "${kind_path}"
    else
        download-bin "${kind_path}" "${KINDURL}"
    fi
}

download-kubectl() {
    KUBECTLVERSION=v1.21.1
    KUBECTLPATH=$(command -v kubectl || echo)
    UNAME=$(uname | awk '{print tolower($0)}')
    KUBECTLURL="https://storage.googleapis.com/kubernetes-release/release/$KUBECTLVERSION/bin/$UNAME/amd64/kubectl"

    local kubectl_path=$1
    # Ensure kubectl exists at the expected version
    if [ -x "${KUBECTLPATH}" ] && "${KUBECTLPATH}" version --short --client=true | grep -q "${KUBECTLVERSION}"; then
        ln -s "${KUBECTLPATH}" "${kubectl_path}"
    else
        download-bin "${kubectl_path}" "${KUBECTLURL}"
    fi
}

start-kind-cluster() {
    local kind_path=$1
    local kind_name=$2
    local kind_config_path=$3

    log-info "starting cluster..."
    "${kind_path}" create cluster --name "${kind_name}" --config "${kind_config_path}" || fail-now "unable to create cluster"
}

load-images() {
    local kind_path=$1; shift
    local kind_name=$1; shift
    local container_images=("$@")

    log-info "loading container images..."
    for image in "${container_images[@]}"; do
        "${kind_path}" load docker-image --name "${kind_name}" "${image}"
    done
}

set-kubectl-context() {
    local kubectl_path=$1
    local context=$2

    log-info "setting kubectl cluster context..."
    "${kubectl_path}" cluster-info --context "${context}"
}
