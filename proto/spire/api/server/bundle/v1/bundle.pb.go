// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spire/api/server/bundle/v1/bundle.proto

package bundle

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	types "github.com/spiffe/spire/proto/spire/types"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Mode controls the delete behavior if there are other records
// associated with the bundle (e.g. registration entries).
type BatchDeleteFederatedBundleRequest_Mode int32

const (
	// RESTRICT prevents the bundle from being deleted in the presence of associated entries
	BatchDeleteFederatedBundleRequest_RESTRICT BatchDeleteFederatedBundleRequest_Mode = 0
	// DELETE deletes the bundle and associated entries
	BatchDeleteFederatedBundleRequest_DELETE BatchDeleteFederatedBundleRequest_Mode = 1
	// DISSOCIATE deletes the bundle and dissociates associated entries
	BatchDeleteFederatedBundleRequest_DISSOCIATE BatchDeleteFederatedBundleRequest_Mode = 2
)

var BatchDeleteFederatedBundleRequest_Mode_name = map[int32]string{
	0: "RESTRICT",
	1: "DELETE",
	2: "DISSOCIATE",
}

var BatchDeleteFederatedBundleRequest_Mode_value = map[string]int32{
	"RESTRICT":   0,
	"DELETE":     1,
	"DISSOCIATE": 2,
}

func (x BatchDeleteFederatedBundleRequest_Mode) String() string {
	return proto.EnumName(BatchDeleteFederatedBundleRequest_Mode_name, int32(x))
}

func (BatchDeleteFederatedBundleRequest_Mode) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{13, 0}
}

type GetBundleRequest struct {
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,1,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetBundleRequest) Reset()         { *m = GetBundleRequest{} }
func (m *GetBundleRequest) String() string { return proto.CompactTextString(m) }
func (*GetBundleRequest) ProtoMessage()    {}
func (*GetBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{0}
}

func (m *GetBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetBundleRequest.Unmarshal(m, b)
}
func (m *GetBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetBundleRequest.Marshal(b, m, deterministic)
}
func (m *GetBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetBundleRequest.Merge(m, src)
}
func (m *GetBundleRequest) XXX_Size() int {
	return xxx_messageInfo_GetBundleRequest.Size(m)
}
func (m *GetBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetBundleRequest proto.InternalMessageInfo

func (m *GetBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type AppendBundleRequest struct {
	// X.509 authorities to append.
	X509Authorities []*types.X509Certificate `protobuf:"bytes,1,rep,name=x509_authorities,json=x509Authorities,proto3" json:"x509_authorities,omitempty"`
	// JWT authorities to append.
	JwtAuthorities []*types.JWTKey `protobuf:"bytes,2,rep,name=jwt_authorities,json=jwtAuthorities,proto3" json:"jwt_authorities,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,3,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *AppendBundleRequest) Reset()         { *m = AppendBundleRequest{} }
func (m *AppendBundleRequest) String() string { return proto.CompactTextString(m) }
func (*AppendBundleRequest) ProtoMessage()    {}
func (*AppendBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{1}
}

func (m *AppendBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AppendBundleRequest.Unmarshal(m, b)
}
func (m *AppendBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AppendBundleRequest.Marshal(b, m, deterministic)
}
func (m *AppendBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AppendBundleRequest.Merge(m, src)
}
func (m *AppendBundleRequest) XXX_Size() int {
	return xxx_messageInfo_AppendBundleRequest.Size(m)
}
func (m *AppendBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AppendBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AppendBundleRequest proto.InternalMessageInfo

func (m *AppendBundleRequest) GetX509Authorities() []*types.X509Certificate {
	if m != nil {
		return m.X509Authorities
	}
	return nil
}

func (m *AppendBundleRequest) GetJwtAuthorities() []*types.JWTKey {
	if m != nil {
		return m.JwtAuthorities
	}
	return nil
}

func (m *AppendBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type PublishJWTAuthorityRequest struct {
	// Required. The JWT authority to publish.
	JwtAuthority         *types.JWTKey `protobuf:"bytes,1,opt,name=jwt_authority,json=jwtAuthority,proto3" json:"jwt_authority,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *PublishJWTAuthorityRequest) Reset()         { *m = PublishJWTAuthorityRequest{} }
func (m *PublishJWTAuthorityRequest) String() string { return proto.CompactTextString(m) }
func (*PublishJWTAuthorityRequest) ProtoMessage()    {}
func (*PublishJWTAuthorityRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{2}
}

func (m *PublishJWTAuthorityRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishJWTAuthorityRequest.Unmarshal(m, b)
}
func (m *PublishJWTAuthorityRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishJWTAuthorityRequest.Marshal(b, m, deterministic)
}
func (m *PublishJWTAuthorityRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishJWTAuthorityRequest.Merge(m, src)
}
func (m *PublishJWTAuthorityRequest) XXX_Size() int {
	return xxx_messageInfo_PublishJWTAuthorityRequest.Size(m)
}
func (m *PublishJWTAuthorityRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishJWTAuthorityRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishJWTAuthorityRequest proto.InternalMessageInfo

func (m *PublishJWTAuthorityRequest) GetJwtAuthority() *types.JWTKey {
	if m != nil {
		return m.JwtAuthority
	}
	return nil
}

type PublishJWTAuthorityResponse struct {
	// The JWT authorities for the trust domain.
	JwtAuthorities       []*types.JWTKey `protobuf:"bytes,1,rep,name=jwt_authorities,json=jwtAuthorities,proto3" json:"jwt_authorities,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *PublishJWTAuthorityResponse) Reset()         { *m = PublishJWTAuthorityResponse{} }
func (m *PublishJWTAuthorityResponse) String() string { return proto.CompactTextString(m) }
func (*PublishJWTAuthorityResponse) ProtoMessage()    {}
func (*PublishJWTAuthorityResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{3}
}

func (m *PublishJWTAuthorityResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishJWTAuthorityResponse.Unmarshal(m, b)
}
func (m *PublishJWTAuthorityResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishJWTAuthorityResponse.Marshal(b, m, deterministic)
}
func (m *PublishJWTAuthorityResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishJWTAuthorityResponse.Merge(m, src)
}
func (m *PublishJWTAuthorityResponse) XXX_Size() int {
	return xxx_messageInfo_PublishJWTAuthorityResponse.Size(m)
}
func (m *PublishJWTAuthorityResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishJWTAuthorityResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishJWTAuthorityResponse proto.InternalMessageInfo

func (m *PublishJWTAuthorityResponse) GetJwtAuthorities() []*types.JWTKey {
	if m != nil {
		return m.JwtAuthorities
	}
	return nil
}

type ListFederatedBundlesRequest struct {
	// An output mask indicating which bundle fields are set in the response.
	OutputMask *types.BundleMask `protobuf:"bytes,1,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	// The maximum number of results to return. The server may further
	// constrain this value, or if zero, choose its own.
	PageSize int32 `protobuf:"varint,2,opt,name=page_size,json=pageSize,proto3" json:"page_size,omitempty"`
	// The next_page_token value returned from a previous request, if any.
	PageToken            string   `protobuf:"bytes,3,opt,name=page_token,json=pageToken,proto3" json:"page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListFederatedBundlesRequest) Reset()         { *m = ListFederatedBundlesRequest{} }
func (m *ListFederatedBundlesRequest) String() string { return proto.CompactTextString(m) }
func (*ListFederatedBundlesRequest) ProtoMessage()    {}
func (*ListFederatedBundlesRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{4}
}

func (m *ListFederatedBundlesRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListFederatedBundlesRequest.Unmarshal(m, b)
}
func (m *ListFederatedBundlesRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListFederatedBundlesRequest.Marshal(b, m, deterministic)
}
func (m *ListFederatedBundlesRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListFederatedBundlesRequest.Merge(m, src)
}
func (m *ListFederatedBundlesRequest) XXX_Size() int {
	return xxx_messageInfo_ListFederatedBundlesRequest.Size(m)
}
func (m *ListFederatedBundlesRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ListFederatedBundlesRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ListFederatedBundlesRequest proto.InternalMessageInfo

func (m *ListFederatedBundlesRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

func (m *ListFederatedBundlesRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

func (m *ListFederatedBundlesRequest) GetPageToken() string {
	if m != nil {
		return m.PageToken
	}
	return ""
}

type ListFederatedBundlesResponse struct {
	// The bundles.
	Bundles []*types.Bundle `protobuf:"bytes,1,rep,name=bundles,proto3" json:"bundles,omitempty"`
	// The page token for the next request. Empty if there are no more results.
	// This field should be checked by clients even when a page_size was not
	// requested, since the server may choose its own (see page_size).
	NextPageToken        string   `protobuf:"bytes,2,opt,name=next_page_token,json=nextPageToken,proto3" json:"next_page_token,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ListFederatedBundlesResponse) Reset()         { *m = ListFederatedBundlesResponse{} }
func (m *ListFederatedBundlesResponse) String() string { return proto.CompactTextString(m) }
func (*ListFederatedBundlesResponse) ProtoMessage()    {}
func (*ListFederatedBundlesResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{5}
}

func (m *ListFederatedBundlesResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ListFederatedBundlesResponse.Unmarshal(m, b)
}
func (m *ListFederatedBundlesResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ListFederatedBundlesResponse.Marshal(b, m, deterministic)
}
func (m *ListFederatedBundlesResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ListFederatedBundlesResponse.Merge(m, src)
}
func (m *ListFederatedBundlesResponse) XXX_Size() int {
	return xxx_messageInfo_ListFederatedBundlesResponse.Size(m)
}
func (m *ListFederatedBundlesResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ListFederatedBundlesResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ListFederatedBundlesResponse proto.InternalMessageInfo

func (m *ListFederatedBundlesResponse) GetBundles() []*types.Bundle {
	if m != nil {
		return m.Bundles
	}
	return nil
}

func (m *ListFederatedBundlesResponse) GetNextPageToken() string {
	if m != nil {
		return m.NextPageToken
	}
	return ""
}

type GetFederatedBundleRequest struct {
	// Required. The trust domain name of the bundle (e.g., "example.org").
	TrustDomain string `protobuf:"bytes,1,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GetFederatedBundleRequest) Reset()         { *m = GetFederatedBundleRequest{} }
func (m *GetFederatedBundleRequest) String() string { return proto.CompactTextString(m) }
func (*GetFederatedBundleRequest) ProtoMessage()    {}
func (*GetFederatedBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{6}
}

func (m *GetFederatedBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GetFederatedBundleRequest.Unmarshal(m, b)
}
func (m *GetFederatedBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GetFederatedBundleRequest.Marshal(b, m, deterministic)
}
func (m *GetFederatedBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetFederatedBundleRequest.Merge(m, src)
}
func (m *GetFederatedBundleRequest) XXX_Size() int {
	return xxx_messageInfo_GetFederatedBundleRequest.Size(m)
}
func (m *GetFederatedBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetFederatedBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetFederatedBundleRequest proto.InternalMessageInfo

func (m *GetFederatedBundleRequest) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func (m *GetFederatedBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchCreateFederatedBundleRequest struct {
	// The bundles to be created.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchCreateFederatedBundleRequest) Reset()         { *m = BatchCreateFederatedBundleRequest{} }
func (m *BatchCreateFederatedBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchCreateFederatedBundleRequest) ProtoMessage()    {}
func (*BatchCreateFederatedBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{7}
}

func (m *BatchCreateFederatedBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateFederatedBundleRequest.Unmarshal(m, b)
}
func (m *BatchCreateFederatedBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateFederatedBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchCreateFederatedBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateFederatedBundleRequest.Merge(m, src)
}
func (m *BatchCreateFederatedBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchCreateFederatedBundleRequest.Size(m)
}
func (m *BatchCreateFederatedBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateFederatedBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateFederatedBundleRequest proto.InternalMessageInfo

func (m *BatchCreateFederatedBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchCreateFederatedBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchCreateFederatedBundleResponse struct {
	// Result for each bundle in the request (order is maintained).
	Results              []*BatchCreateFederatedBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *BatchCreateFederatedBundleResponse) Reset()         { *m = BatchCreateFederatedBundleResponse{} }
func (m *BatchCreateFederatedBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchCreateFederatedBundleResponse) ProtoMessage()    {}
func (*BatchCreateFederatedBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{8}
}

func (m *BatchCreateFederatedBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse.Unmarshal(m, b)
}
func (m *BatchCreateFederatedBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchCreateFederatedBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateFederatedBundleResponse.Merge(m, src)
}
func (m *BatchCreateFederatedBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse.Size(m)
}
func (m *BatchCreateFederatedBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateFederatedBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateFederatedBundleResponse proto.InternalMessageInfo

func (m *BatchCreateFederatedBundleResponse) GetResults() []*BatchCreateFederatedBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchCreateFederatedBundleResponse_Result struct {
	// The status of creating the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was created. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchCreateFederatedBundleResponse_Result) Reset() {
	*m = BatchCreateFederatedBundleResponse_Result{}
}
func (m *BatchCreateFederatedBundleResponse_Result) String() string {
	return proto.CompactTextString(m)
}
func (*BatchCreateFederatedBundleResponse_Result) ProtoMessage() {}
func (*BatchCreateFederatedBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{8, 0}
}

func (m *BatchCreateFederatedBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchCreateFederatedBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchCreateFederatedBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchCreateFederatedBundleResponse_Result.Merge(m, src)
}
func (m *BatchCreateFederatedBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchCreateFederatedBundleResponse_Result.Size(m)
}
func (m *BatchCreateFederatedBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchCreateFederatedBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchCreateFederatedBundleResponse_Result proto.InternalMessageInfo

func (m *BatchCreateFederatedBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchCreateFederatedBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type BatchUpdateFederatedBundleRequest struct {
	// The bundles to be updated.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An input mask indicating which bundle fields should be updated.
	InputMask *types.BundleMask `protobuf:"bytes,2,opt,name=input_mask,json=inputMask,proto3" json:"input_mask,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,3,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchUpdateFederatedBundleRequest) Reset()         { *m = BatchUpdateFederatedBundleRequest{} }
func (m *BatchUpdateFederatedBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateFederatedBundleRequest) ProtoMessage()    {}
func (*BatchUpdateFederatedBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{9}
}

func (m *BatchUpdateFederatedBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateFederatedBundleRequest.Unmarshal(m, b)
}
func (m *BatchUpdateFederatedBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateFederatedBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchUpdateFederatedBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateFederatedBundleRequest.Merge(m, src)
}
func (m *BatchUpdateFederatedBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateFederatedBundleRequest.Size(m)
}
func (m *BatchUpdateFederatedBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateFederatedBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateFederatedBundleRequest proto.InternalMessageInfo

func (m *BatchUpdateFederatedBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchUpdateFederatedBundleRequest) GetInputMask() *types.BundleMask {
	if m != nil {
		return m.InputMask
	}
	return nil
}

func (m *BatchUpdateFederatedBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchUpdateFederatedBundleResponse struct {
	// Result for each bundle in the request (order is maintained).
	Results              []*BatchUpdateFederatedBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *BatchUpdateFederatedBundleResponse) Reset()         { *m = BatchUpdateFederatedBundleResponse{} }
func (m *BatchUpdateFederatedBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchUpdateFederatedBundleResponse) ProtoMessage()    {}
func (*BatchUpdateFederatedBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{10}
}

func (m *BatchUpdateFederatedBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse.Unmarshal(m, b)
}
func (m *BatchUpdateFederatedBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchUpdateFederatedBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateFederatedBundleResponse.Merge(m, src)
}
func (m *BatchUpdateFederatedBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse.Size(m)
}
func (m *BatchUpdateFederatedBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateFederatedBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateFederatedBundleResponse proto.InternalMessageInfo

func (m *BatchUpdateFederatedBundleResponse) GetResults() []*BatchUpdateFederatedBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchUpdateFederatedBundleResponse_Result struct {
	// The status of updating the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was updated. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchUpdateFederatedBundleResponse_Result) Reset() {
	*m = BatchUpdateFederatedBundleResponse_Result{}
}
func (m *BatchUpdateFederatedBundleResponse_Result) String() string {
	return proto.CompactTextString(m)
}
func (*BatchUpdateFederatedBundleResponse_Result) ProtoMessage() {}
func (*BatchUpdateFederatedBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{10, 0}
}

func (m *BatchUpdateFederatedBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchUpdateFederatedBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchUpdateFederatedBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result.Merge(m, src)
}
func (m *BatchUpdateFederatedBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result.Size(m)
}
func (m *BatchUpdateFederatedBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchUpdateFederatedBundleResponse_Result proto.InternalMessageInfo

func (m *BatchUpdateFederatedBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchUpdateFederatedBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type BatchSetFederatedBundleRequest struct {
	// The bundles to be upserted.
	Bundle []*types.Bundle `protobuf:"bytes,1,rep,name=bundle,proto3" json:"bundle,omitempty"`
	// An output mask indicating which bundle fields are set in the response.
	OutputMask           *types.BundleMask `protobuf:"bytes,2,opt,name=output_mask,json=outputMask,proto3" json:"output_mask,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *BatchSetFederatedBundleRequest) Reset()         { *m = BatchSetFederatedBundleRequest{} }
func (m *BatchSetFederatedBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchSetFederatedBundleRequest) ProtoMessage()    {}
func (*BatchSetFederatedBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{11}
}

func (m *BatchSetFederatedBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetFederatedBundleRequest.Unmarshal(m, b)
}
func (m *BatchSetFederatedBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetFederatedBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchSetFederatedBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetFederatedBundleRequest.Merge(m, src)
}
func (m *BatchSetFederatedBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchSetFederatedBundleRequest.Size(m)
}
func (m *BatchSetFederatedBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetFederatedBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetFederatedBundleRequest proto.InternalMessageInfo

func (m *BatchSetFederatedBundleRequest) GetBundle() []*types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

func (m *BatchSetFederatedBundleRequest) GetOutputMask() *types.BundleMask {
	if m != nil {
		return m.OutputMask
	}
	return nil
}

type BatchSetFederatedBundleResponse struct {
	// Result for each bundle in the request (order is maintained).
	Results              []*BatchSetFederatedBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                  `json:"-"`
	XXX_unrecognized     []byte                                    `json:"-"`
	XXX_sizecache        int32                                     `json:"-"`
}

func (m *BatchSetFederatedBundleResponse) Reset()         { *m = BatchSetFederatedBundleResponse{} }
func (m *BatchSetFederatedBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchSetFederatedBundleResponse) ProtoMessage()    {}
func (*BatchSetFederatedBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{12}
}

func (m *BatchSetFederatedBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetFederatedBundleResponse.Unmarshal(m, b)
}
func (m *BatchSetFederatedBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetFederatedBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchSetFederatedBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetFederatedBundleResponse.Merge(m, src)
}
func (m *BatchSetFederatedBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchSetFederatedBundleResponse.Size(m)
}
func (m *BatchSetFederatedBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetFederatedBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetFederatedBundleResponse proto.InternalMessageInfo

func (m *BatchSetFederatedBundleResponse) GetResults() []*BatchSetFederatedBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchSetFederatedBundleResponse_Result struct {
	// The status of upserting the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The bundle that was upserted. This will be set if the status is OK.
	Bundle               *types.Bundle `protobuf:"bytes,2,opt,name=bundle,proto3" json:"bundle,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *BatchSetFederatedBundleResponse_Result) Reset() {
	*m = BatchSetFederatedBundleResponse_Result{}
}
func (m *BatchSetFederatedBundleResponse_Result) String() string { return proto.CompactTextString(m) }
func (*BatchSetFederatedBundleResponse_Result) ProtoMessage()    {}
func (*BatchSetFederatedBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{12, 0}
}

func (m *BatchSetFederatedBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchSetFederatedBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchSetFederatedBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchSetFederatedBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchSetFederatedBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchSetFederatedBundleResponse_Result.Merge(m, src)
}
func (m *BatchSetFederatedBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchSetFederatedBundleResponse_Result.Size(m)
}
func (m *BatchSetFederatedBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchSetFederatedBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchSetFederatedBundleResponse_Result proto.InternalMessageInfo

func (m *BatchSetFederatedBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchSetFederatedBundleResponse_Result) GetBundle() *types.Bundle {
	if m != nil {
		return m.Bundle
	}
	return nil
}

type BatchDeleteFederatedBundleRequest struct {
	// The trust domain names (e.g., "example.org") of the bundles to delete.
	TrustDomains []string `protobuf:"bytes,1,rep,name=trust_domains,json=trustDomains,proto3" json:"trust_domains,omitempty"`
	// The deletion mode selected
	Mode                 BatchDeleteFederatedBundleRequest_Mode `protobuf:"varint,2,opt,name=mode,proto3,enum=spire.api.server.bundle.v1.BatchDeleteFederatedBundleRequest_Mode" json:"mode,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                               `json:"-"`
	XXX_unrecognized     []byte                                 `json:"-"`
	XXX_sizecache        int32                                  `json:"-"`
}

func (m *BatchDeleteFederatedBundleRequest) Reset()         { *m = BatchDeleteFederatedBundleRequest{} }
func (m *BatchDeleteFederatedBundleRequest) String() string { return proto.CompactTextString(m) }
func (*BatchDeleteFederatedBundleRequest) ProtoMessage()    {}
func (*BatchDeleteFederatedBundleRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{13}
}

func (m *BatchDeleteFederatedBundleRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteFederatedBundleRequest.Unmarshal(m, b)
}
func (m *BatchDeleteFederatedBundleRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteFederatedBundleRequest.Marshal(b, m, deterministic)
}
func (m *BatchDeleteFederatedBundleRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteFederatedBundleRequest.Merge(m, src)
}
func (m *BatchDeleteFederatedBundleRequest) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteFederatedBundleRequest.Size(m)
}
func (m *BatchDeleteFederatedBundleRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteFederatedBundleRequest.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteFederatedBundleRequest proto.InternalMessageInfo

func (m *BatchDeleteFederatedBundleRequest) GetTrustDomains() []string {
	if m != nil {
		return m.TrustDomains
	}
	return nil
}

func (m *BatchDeleteFederatedBundleRequest) GetMode() BatchDeleteFederatedBundleRequest_Mode {
	if m != nil {
		return m.Mode
	}
	return BatchDeleteFederatedBundleRequest_RESTRICT
}

type BatchDeleteFederatedBundleResponse struct {
	// Result for each trust domain name in the request (order is maintained).
	Results              []*BatchDeleteFederatedBundleResponse_Result `protobuf:"bytes,1,rep,name=results,proto3" json:"results,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                                     `json:"-"`
	XXX_unrecognized     []byte                                       `json:"-"`
	XXX_sizecache        int32                                        `json:"-"`
}

func (m *BatchDeleteFederatedBundleResponse) Reset()         { *m = BatchDeleteFederatedBundleResponse{} }
func (m *BatchDeleteFederatedBundleResponse) String() string { return proto.CompactTextString(m) }
func (*BatchDeleteFederatedBundleResponse) ProtoMessage()    {}
func (*BatchDeleteFederatedBundleResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{14}
}

func (m *BatchDeleteFederatedBundleResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse.Unmarshal(m, b)
}
func (m *BatchDeleteFederatedBundleResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse.Marshal(b, m, deterministic)
}
func (m *BatchDeleteFederatedBundleResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteFederatedBundleResponse.Merge(m, src)
}
func (m *BatchDeleteFederatedBundleResponse) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse.Size(m)
}
func (m *BatchDeleteFederatedBundleResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteFederatedBundleResponse.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteFederatedBundleResponse proto.InternalMessageInfo

func (m *BatchDeleteFederatedBundleResponse) GetResults() []*BatchDeleteFederatedBundleResponse_Result {
	if m != nil {
		return m.Results
	}
	return nil
}

type BatchDeleteFederatedBundleResponse_Result struct {
	// The status of deleting the bundle.
	Status *types.Status `protobuf:"bytes,1,opt,name=status,proto3" json:"status,omitempty"`
	// The trust domain name (e.g., "example.org") of the bundle that was
	// deleted.
	TrustDomain          string   `protobuf:"bytes,2,opt,name=trust_domain,json=trustDomain,proto3" json:"trust_domain,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *BatchDeleteFederatedBundleResponse_Result) Reset() {
	*m = BatchDeleteFederatedBundleResponse_Result{}
}
func (m *BatchDeleteFederatedBundleResponse_Result) String() string {
	return proto.CompactTextString(m)
}
func (*BatchDeleteFederatedBundleResponse_Result) ProtoMessage() {}
func (*BatchDeleteFederatedBundleResponse_Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_1be5798075a8d648, []int{14, 0}
}

func (m *BatchDeleteFederatedBundleResponse_Result) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result.Unmarshal(m, b)
}
func (m *BatchDeleteFederatedBundleResponse_Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result.Marshal(b, m, deterministic)
}
func (m *BatchDeleteFederatedBundleResponse_Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result.Merge(m, src)
}
func (m *BatchDeleteFederatedBundleResponse_Result) XXX_Size() int {
	return xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result.Size(m)
}
func (m *BatchDeleteFederatedBundleResponse_Result) XXX_DiscardUnknown() {
	xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result.DiscardUnknown(m)
}

var xxx_messageInfo_BatchDeleteFederatedBundleResponse_Result proto.InternalMessageInfo

func (m *BatchDeleteFederatedBundleResponse_Result) GetStatus() *types.Status {
	if m != nil {
		return m.Status
	}
	return nil
}

func (m *BatchDeleteFederatedBundleResponse_Result) GetTrustDomain() string {
	if m != nil {
		return m.TrustDomain
	}
	return ""
}

func init() {
	proto.RegisterEnum("spire.api.server.bundle.v1.BatchDeleteFederatedBundleRequest_Mode", BatchDeleteFederatedBundleRequest_Mode_name, BatchDeleteFederatedBundleRequest_Mode_value)
	proto.RegisterType((*GetBundleRequest)(nil), "spire.api.server.bundle.v1.GetBundleRequest")
	proto.RegisterType((*AppendBundleRequest)(nil), "spire.api.server.bundle.v1.AppendBundleRequest")
	proto.RegisterType((*PublishJWTAuthorityRequest)(nil), "spire.api.server.bundle.v1.PublishJWTAuthorityRequest")
	proto.RegisterType((*PublishJWTAuthorityResponse)(nil), "spire.api.server.bundle.v1.PublishJWTAuthorityResponse")
	proto.RegisterType((*ListFederatedBundlesRequest)(nil), "spire.api.server.bundle.v1.ListFederatedBundlesRequest")
	proto.RegisterType((*ListFederatedBundlesResponse)(nil), "spire.api.server.bundle.v1.ListFederatedBundlesResponse")
	proto.RegisterType((*GetFederatedBundleRequest)(nil), "spire.api.server.bundle.v1.GetFederatedBundleRequest")
	proto.RegisterType((*BatchCreateFederatedBundleRequest)(nil), "spire.api.server.bundle.v1.BatchCreateFederatedBundleRequest")
	proto.RegisterType((*BatchCreateFederatedBundleResponse)(nil), "spire.api.server.bundle.v1.BatchCreateFederatedBundleResponse")
	proto.RegisterType((*BatchCreateFederatedBundleResponse_Result)(nil), "spire.api.server.bundle.v1.BatchCreateFederatedBundleResponse.Result")
	proto.RegisterType((*BatchUpdateFederatedBundleRequest)(nil), "spire.api.server.bundle.v1.BatchUpdateFederatedBundleRequest")
	proto.RegisterType((*BatchUpdateFederatedBundleResponse)(nil), "spire.api.server.bundle.v1.BatchUpdateFederatedBundleResponse")
	proto.RegisterType((*BatchUpdateFederatedBundleResponse_Result)(nil), "spire.api.server.bundle.v1.BatchUpdateFederatedBundleResponse.Result")
	proto.RegisterType((*BatchSetFederatedBundleRequest)(nil), "spire.api.server.bundle.v1.BatchSetFederatedBundleRequest")
	proto.RegisterType((*BatchSetFederatedBundleResponse)(nil), "spire.api.server.bundle.v1.BatchSetFederatedBundleResponse")
	proto.RegisterType((*BatchSetFederatedBundleResponse_Result)(nil), "spire.api.server.bundle.v1.BatchSetFederatedBundleResponse.Result")
	proto.RegisterType((*BatchDeleteFederatedBundleRequest)(nil), "spire.api.server.bundle.v1.BatchDeleteFederatedBundleRequest")
	proto.RegisterType((*BatchDeleteFederatedBundleResponse)(nil), "spire.api.server.bundle.v1.BatchDeleteFederatedBundleResponse")
	proto.RegisterType((*BatchDeleteFederatedBundleResponse_Result)(nil), "spire.api.server.bundle.v1.BatchDeleteFederatedBundleResponse.Result")
}

func init() {
	proto.RegisterFile("spire/api/server/bundle/v1/bundle.proto", fileDescriptor_1be5798075a8d648)
}

var fileDescriptor_1be5798075a8d648 = []byte{
	// 907 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xdd, 0x6e, 0xe3, 0x44,
	0x14, 0x66, 0xb2, 0x4b, 0x76, 0x73, 0x92, 0xb6, 0xd1, 0x14, 0x69, 0x83, 0xbb, 0x40, 0xd7, 0x48,
	0x50, 0x09, 0xb0, 0xbb, 0x45, 0x5d, 0x76, 0x59, 0x7e, 0x94, 0x3f, 0xaa, 0x2e, 0x5d, 0xa8, 0x1c,
	0xd3, 0x56, 0x80, 0x14, 0x9c, 0x66, 0xda, 0xb8, 0x4d, 0x62, 0xe3, 0x19, 0xb7, 0x4d, 0x1f, 0x00,
	0x04, 0x97, 0xc0, 0x1d, 0x6f, 0xc3, 0x23, 0x70, 0xc1, 0x2d, 0x17, 0x5c, 0xf1, 0x16, 0x28, 0x33,
	0x76, 0xe3, 0xa4, 0x63, 0xd7, 0x4d, 0xd0, 0xf6, 0x2e, 0x99, 0x39, 0xe7, 0x3b, 0xe7, 0x7c, 0x67,
	0xce, 0x8f, 0xe1, 0x6d, 0xea, 0xda, 0x1e, 0xd1, 0x2d, 0xd7, 0xd6, 0x29, 0xf1, 0x4e, 0x88, 0xa7,
	0xb7, 0xfc, 0x7e, 0xbb, 0x4b, 0xf4, 0x93, 0x87, 0xc1, 0x2f, 0xcd, 0xf5, 0x1c, 0xe6, 0x60, 0x85,
	0x0b, 0x6a, 0x96, 0x6b, 0x6b, 0x42, 0x50, 0x0b, 0xae, 0x4f, 0x1e, 0x2a, 0x25, 0x01, 0xc2, 0x06,
	0x2e, 0xa1, 0x63, 0x5a, 0xe3, 0x37, 0x94, 0x59, 0xcc, 0xa7, 0xe2, 0x46, 0xdd, 0x82, 0xe2, 0x06,
	0x61, 0x15, 0x2e, 0x6c, 0x90, 0xef, 0x7d, 0x42, 0x19, 0x7e, 0x0c, 0x79, 0xc7, 0x67, 0xae, 0xcf,
	0x9a, 0x3d, 0x8b, 0x1e, 0x97, 0xd0, 0x32, 0x5a, 0xc9, 0xaf, 0xdd, 0xd3, 0x84, 0x65, 0x8e, 0xa1,
	0x09, 0x85, 0xe7, 0x16, 0x3d, 0x36, 0x40, 0xc8, 0x0e, 0x7f, 0xab, 0x7f, 0x21, 0x58, 0x2c, 0xbb,
	0x2e, 0xe9, 0xb7, 0xc7, 0x11, 0x37, 0xa0, 0x78, 0xb6, 0xbe, 0xfa, 0xa4, 0x69, 0xf9, 0xac, 0xe3,
	0x78, 0x36, 0xb3, 0x09, 0x2d, 0xa1, 0xe5, 0x5b, 0x2b, 0xf9, 0xb5, 0xfb, 0x63, 0xb0, 0x7b, 0xeb,
	0xab, 0x4f, 0xaa, 0xc4, 0x63, 0xf6, 0x81, 0xbd, 0x6f, 0x31, 0x62, 0x2c, 0x0c, 0xb5, 0xca, 0x23,
	0x25, 0xfc, 0x11, 0x2c, 0x1c, 0x9d, 0xb2, 0x31, 0x9c, 0x0c, 0xc7, 0x59, 0x1c, 0xc3, 0x79, 0xb6,
	0x6b, 0x7e, 0x4e, 0x06, 0xc6, 0xfc, 0xd1, 0x29, 0x8b, 0x6a, 0x4f, 0x04, 0x76, 0x2b, 0x7d, 0x60,
	0x3b, 0xa0, 0x6c, 0xfb, 0xad, 0xae, 0x4d, 0x3b, 0xcf, 0x76, 0xcd, 0x10, 0x72, 0x30, 0x22, 0x6c,
	0x2e, 0xea, 0xd5, 0x20, 0xa0, 0x4c, 0xea, 0x53, 0x21, 0xe2, 0xd3, 0x40, 0xfd, 0x06, 0x96, 0xa4,
	0xb8, 0xd4, 0x75, 0xfa, 0x94, 0xc8, 0xc2, 0x45, 0xa9, 0xc3, 0x55, 0x7f, 0x45, 0xb0, 0xb4, 0x65,
	0x53, 0xf6, 0x19, 0x69, 0x13, 0xcf, 0x62, 0x24, 0x48, 0x0a, 0x9d, 0x39, 0xcf, 0x78, 0x09, 0x72,
	0xae, 0x75, 0x48, 0x9a, 0xd4, 0x3e, 0x27, 0xa5, 0xcc, 0x32, 0x5a, 0x79, 0xd9, 0xb8, 0x3b, 0x3c,
	0x68, 0xd8, 0xe7, 0x04, 0xbf, 0x06, 0xc0, 0x2f, 0x99, 0x73, 0x4c, 0xfa, 0x9c, 0xe4, 0x9c, 0xc1,
	0xc5, 0xcd, 0xe1, 0x81, 0xea, 0xc3, 0x7d, 0xb9, 0x53, 0x41, 0xcc, 0xef, 0xc1, 0x1d, 0xf1, 0x76,
	0xe5, 0xb1, 0x06, 0x0f, 0x2b, 0x94, 0xc1, 0x6f, 0xc1, 0x42, 0x9f, 0x9c, 0xb1, 0x66, 0xc4, 0x64,
	0x86, 0x9b, 0x9c, 0x1b, 0x1e, 0x6f, 0x5f, 0x98, 0x3d, 0x83, 0x57, 0x37, 0xc8, 0xa4, 0xd5, 0x90,
	0x89, 0x07, 0x50, 0x60, 0x9e, 0x4f, 0x59, 0xb3, 0xed, 0xf4, 0x2c, 0xbb, 0xcf, 0xa9, 0xc8, 0x19,
	0x79, 0x7e, 0x56, 0xe3, 0x47, 0x93, 0x64, 0x65, 0xd2, 0xbf, 0x9d, 0x9f, 0x11, 0x3c, 0xa8, 0x58,
	0x6c, 0xbf, 0x53, 0xf5, 0x88, 0xc5, 0x48, 0x8c, 0x0b, 0xef, 0x40, 0x56, 0x84, 0x94, 0x14, 0x75,
	0x20, 0x32, 0x83, 0x33, 0xff, 0x22, 0x50, 0x93, 0x9c, 0x09, 0x92, 0xd0, 0x84, 0x3b, 0x1e, 0xa1,
	0x7e, 0x97, 0x85, 0x49, 0xa8, 0x6b, 0xf1, 0x8d, 0x47, 0xbb, 0x1a, 0x50, 0x33, 0x38, 0x9a, 0x11,
	0xa2, 0x2a, 0x2d, 0xc8, 0x8a, 0xa3, 0x61, 0xe0, 0xa2, 0x23, 0x49, 0xab, 0xa6, 0xc1, 0xaf, 0x8c,
	0x40, 0x24, 0xc2, 0x52, 0x46, 0x22, 0x3c, 0xce, 0x92, 0xfa, 0x47, 0x48, 0xfc, 0x57, 0x6e, 0xfb,
	0x7f, 0x22, 0xfe, 0x11, 0x80, 0xdd, 0x4f, 0xcb, 0x7b, 0x8e, 0x8b, 0xf2, 0x82, 0x99, 0xbe, 0xf3,
	0x5c, 0x24, 0x2c, 0x26, 0x88, 0xe9, 0x13, 0x96, 0x08, 0x78, 0x23, 0x09, 0xfb, 0x11, 0xc1, 0xeb,
	0xdc, 0xb5, 0x46, 0x6c, 0xa5, 0xbe, 0xa0, 0x32, 0xf9, 0x07, 0xc1, 0x1b, 0xb1, 0x9e, 0x04, 0x94,
	0x7f, 0x3b, 0x49, 0x79, 0xe5, 0x4a, 0xca, 0xe3, 0xd1, 0x6e, 0x84, 0xef, 0x3f, 0xc3, 0x02, 0xa9,
	0x91, 0x2e, 0x89, 0x2d, 0x90, 0x37, 0x61, 0x2e, 0xda, 0x1c, 0x45, 0xb4, 0x39, 0xa3, 0x10, 0xe9,
	0x8e, 0x14, 0xef, 0xc0, 0xed, 0x9e, 0xd3, 0x16, 0x56, 0xe7, 0x53, 0x30, 0x91, 0x64, 0x51, 0x7b,
	0xee, 0xb4, 0x89, 0xc1, 0xf1, 0xd4, 0x55, 0xb8, 0x3d, 0xfc, 0x87, 0x0b, 0x70, 0xd7, 0xa8, 0x37,
	0x4c, 0x63, 0xb3, 0x6a, 0x16, 0x5f, 0xc2, 0x00, 0xd9, 0x5a, 0x7d, 0xab, 0x6e, 0xd6, 0x8b, 0x08,
	0xcf, 0x03, 0xd4, 0x36, 0x1b, 0x8d, 0x2f, 0xab, 0x9b, 0x65, 0xb3, 0x5e, 0xcc, 0xa8, 0x7f, 0x87,
	0x05, 0x13, 0x63, 0x62, 0xfa, 0x82, 0x49, 0x04, 0xbc, 0x94, 0xc0, 0xbd, 0xe9, 0x12, 0x38, 0x39,
	0x8a, 0x32, 0x97, 0x46, 0xd1, 0xda, 0x6f, 0x39, 0xc8, 0x0a, 0xe3, 0xf8, 0x0b, 0xc8, 0x5d, 0xac,
	0x6f, 0xf8, 0xdd, 0xa4, 0x08, 0x26, 0xb7, 0x3c, 0x45, 0xf6, 0x32, 0xb0, 0x09, 0x85, 0xe8, 0xfe,
	0x86, 0xf5, 0x24, 0x48, 0xc9, 0xa6, 0x27, 0x47, 0xfd, 0x01, 0xc1, 0xa2, 0x64, 0xcd, 0xc1, 0x8f,
	0x92, 0xd0, 0xe3, 0xf7, 0x2d, 0xe5, 0x83, 0x6b, 0xeb, 0x05, 0x49, 0xff, 0x09, 0xc1, 0x2b, 0xb2,
	0xe5, 0x03, 0x27, 0x22, 0x26, 0xec, 0x50, 0xca, 0xe3, 0xeb, 0x2b, 0x06, 0xbe, 0x7c, 0x07, 0xf8,
	0xf2, 0x42, 0x82, 0xd7, 0xaf, 0xc8, 0xa1, 0xbc, 0x62, 0xe4, 0xb4, 0xff, 0x8e, 0x40, 0x89, 0x1f,
	0xcd, 0xf8, 0xe3, 0x69, 0x47, 0xba, 0x30, 0xf9, 0xc9, 0x6c, 0x1b, 0xc1, 0xc8, 0x3b, 0xe9, 0x1c,
	0x4a, 0xe1, 0x5d, 0xd2, 0x54, 0x4f, 0xe1, 0x5d, 0xf2, 0x3c, 0xfd, 0x05, 0xc1, 0xbd, 0x98, 0x96,
	0x8d, 0x3f, 0x9c, 0xaa, 0xcf, 0x0b, 0xbf, 0x9e, 0xce, 0x30, 0x23, 0x46, 0x94, 0x49, 0x3b, 0x51,
	0x0a, 0xca, 0x92, 0xba, 0x6e, 0x0a, 0xca, 0x12, 0x1b, 0x60, 0xa5, 0xfc, 0xf5, 0xa7, 0x87, 0x36,
	0xeb, 0xf8, 0x2d, 0x6d, 0xdf, 0xe9, 0xe9, 0xd4, 0xb5, 0x0f, 0x0e, 0x88, 0x2e, 0x3e, 0x3c, 0xf9,
	0xb7, 0xa6, 0x1e, 0xff, 0x8d, 0xfb, 0x54, 0xfc, 0x6a, 0x65, 0xb9, 0xe0, 0xfb, 0xff, 0x05, 0x00,
	0x00, 0xff, 0xff, 0x81, 0xb5, 0x65, 0xbc, 0x0f, 0x0f, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConnInterface

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// BundleClient is the client API for Bundle service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type BundleClient interface {
	// Gets the bundle for the trust domain of the server.
	//
	// The RPC does not require authentication.
	GetBundle(ctx context.Context, in *GetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Append to the bundle. Items specified in the bundle in the request are
	// appended to the existing bundle. If the bundle does not exist, NOT_FOUND
	// is returned. This is the only RPC that can be used to update the
	// bundle for the trust domain of the SPIRE server.
	//
	// The caller must be local or present an admin X509-SVID.
	AppendBundle(ctx context.Context, in *AppendBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Publishes a downstream JWT authority to the SPIRE server. If the server
	// is itself a downstream server (i.e. configured with an UpstreamAuthority
	// plugin), the JWT authority is published further upstream using the
	// UpstreamAuthority plugin. If the server is not a downstream server, or
	// if the UpstreamAuthority does not support publishing JWT authorities,
	// the server appends the JWT authority to its own bundle.
	//
	// The caller must present a downstream X509-SVID.
	PublishJWTAuthority(ctx context.Context, in *PublishJWTAuthorityRequest, opts ...grpc.CallOption) (*PublishJWTAuthorityResponse, error)
	// Lists federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	ListFederatedBundles(ctx context.Context, in *ListFederatedBundlesRequest, opts ...grpc.CallOption) (*ListFederatedBundlesResponse, error)
	// Gets a federated bundle. If the bundle does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin or an active agent X509-SVID.
	GetFederatedBundle(ctx context.Context, in *GetFederatedBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error)
	// Batch creates one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateFederatedBundle(ctx context.Context, in *BatchCreateFederatedBundleRequest, opts ...grpc.CallOption) (*BatchCreateFederatedBundleResponse, error)
	// Batch updates one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateFederatedBundle(ctx context.Context, in *BatchUpdateFederatedBundleRequest, opts ...grpc.CallOption) (*BatchUpdateFederatedBundleResponse, error)
	// Batch upserts one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchSetFederatedBundle(ctx context.Context, in *BatchSetFederatedBundleRequest, opts ...grpc.CallOption) (*BatchSetFederatedBundleResponse, error)
	// Batch deletes one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteFederatedBundle(ctx context.Context, in *BatchDeleteFederatedBundleRequest, opts ...grpc.CallOption) (*BatchDeleteFederatedBundleResponse, error)
}

type bundleClient struct {
	cc grpc.ClientConnInterface
}

func NewBundleClient(cc grpc.ClientConnInterface) BundleClient {
	return &bundleClient{cc}
}

func (c *bundleClient) GetBundle(ctx context.Context, in *GetBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/GetBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) AppendBundle(ctx context.Context, in *AppendBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/AppendBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) PublishJWTAuthority(ctx context.Context, in *PublishJWTAuthorityRequest, opts ...grpc.CallOption) (*PublishJWTAuthorityResponse, error) {
	out := new(PublishJWTAuthorityResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/PublishJWTAuthority", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) ListFederatedBundles(ctx context.Context, in *ListFederatedBundlesRequest, opts ...grpc.CallOption) (*ListFederatedBundlesResponse, error) {
	out := new(ListFederatedBundlesResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/ListFederatedBundles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) GetFederatedBundle(ctx context.Context, in *GetFederatedBundleRequest, opts ...grpc.CallOption) (*types.Bundle, error) {
	out := new(types.Bundle)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/GetFederatedBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchCreateFederatedBundle(ctx context.Context, in *BatchCreateFederatedBundleRequest, opts ...grpc.CallOption) (*BatchCreateFederatedBundleResponse, error) {
	out := new(BatchCreateFederatedBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/BatchCreateFederatedBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchUpdateFederatedBundle(ctx context.Context, in *BatchUpdateFederatedBundleRequest, opts ...grpc.CallOption) (*BatchUpdateFederatedBundleResponse, error) {
	out := new(BatchUpdateFederatedBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/BatchUpdateFederatedBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchSetFederatedBundle(ctx context.Context, in *BatchSetFederatedBundleRequest, opts ...grpc.CallOption) (*BatchSetFederatedBundleResponse, error) {
	out := new(BatchSetFederatedBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/BatchSetFederatedBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *bundleClient) BatchDeleteFederatedBundle(ctx context.Context, in *BatchDeleteFederatedBundleRequest, opts ...grpc.CallOption) (*BatchDeleteFederatedBundleResponse, error) {
	out := new(BatchDeleteFederatedBundleResponse)
	err := c.cc.Invoke(ctx, "/spire.api.server.bundle.v1.Bundle/BatchDeleteFederatedBundle", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BundleServer is the server API for Bundle service.
type BundleServer interface {
	// Gets the bundle for the trust domain of the server.
	//
	// The RPC does not require authentication.
	GetBundle(context.Context, *GetBundleRequest) (*types.Bundle, error)
	// Append to the bundle. Items specified in the bundle in the request are
	// appended to the existing bundle. If the bundle does not exist, NOT_FOUND
	// is returned. This is the only RPC that can be used to update the
	// bundle for the trust domain of the SPIRE server.
	//
	// The caller must be local or present an admin X509-SVID.
	AppendBundle(context.Context, *AppendBundleRequest) (*types.Bundle, error)
	// Publishes a downstream JWT authority to the SPIRE server. If the server
	// is itself a downstream server (i.e. configured with an UpstreamAuthority
	// plugin), the JWT authority is published further upstream using the
	// UpstreamAuthority plugin. If the server is not a downstream server, or
	// if the UpstreamAuthority does not support publishing JWT authorities,
	// the server appends the JWT authority to its own bundle.
	//
	// The caller must present a downstream X509-SVID.
	PublishJWTAuthority(context.Context, *PublishJWTAuthorityRequest) (*PublishJWTAuthorityResponse, error)
	// Lists federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	ListFederatedBundles(context.Context, *ListFederatedBundlesRequest) (*ListFederatedBundlesResponse, error)
	// Gets a federated bundle. If the bundle does not exist, NOT_FOUND is returned.
	//
	// The caller must be local or present an admin or an active agent X509-SVID.
	GetFederatedBundle(context.Context, *GetFederatedBundleRequest) (*types.Bundle, error)
	// Batch creates one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchCreateFederatedBundle(context.Context, *BatchCreateFederatedBundleRequest) (*BatchCreateFederatedBundleResponse, error)
	// Batch updates one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchUpdateFederatedBundle(context.Context, *BatchUpdateFederatedBundleRequest) (*BatchUpdateFederatedBundleResponse, error)
	// Batch upserts one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchSetFederatedBundle(context.Context, *BatchSetFederatedBundleRequest) (*BatchSetFederatedBundleResponse, error)
	// Batch deletes one or more federated bundles.
	//
	// The caller must be local or present an admin X509-SVID.
	BatchDeleteFederatedBundle(context.Context, *BatchDeleteFederatedBundleRequest) (*BatchDeleteFederatedBundleResponse, error)
}

// UnimplementedBundleServer can be embedded to have forward compatible implementations.
type UnimplementedBundleServer struct {
}

func (*UnimplementedBundleServer) GetBundle(ctx context.Context, req *GetBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetBundle not implemented")
}
func (*UnimplementedBundleServer) AppendBundle(ctx context.Context, req *AppendBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AppendBundle not implemented")
}
func (*UnimplementedBundleServer) PublishJWTAuthority(ctx context.Context, req *PublishJWTAuthorityRequest) (*PublishJWTAuthorityResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishJWTAuthority not implemented")
}
func (*UnimplementedBundleServer) ListFederatedBundles(ctx context.Context, req *ListFederatedBundlesRequest) (*ListFederatedBundlesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListFederatedBundles not implemented")
}
func (*UnimplementedBundleServer) GetFederatedBundle(ctx context.Context, req *GetFederatedBundleRequest) (*types.Bundle, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFederatedBundle not implemented")
}
func (*UnimplementedBundleServer) BatchCreateFederatedBundle(ctx context.Context, req *BatchCreateFederatedBundleRequest) (*BatchCreateFederatedBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchCreateFederatedBundle not implemented")
}
func (*UnimplementedBundleServer) BatchUpdateFederatedBundle(ctx context.Context, req *BatchUpdateFederatedBundleRequest) (*BatchUpdateFederatedBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchUpdateFederatedBundle not implemented")
}
func (*UnimplementedBundleServer) BatchSetFederatedBundle(ctx context.Context, req *BatchSetFederatedBundleRequest) (*BatchSetFederatedBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchSetFederatedBundle not implemented")
}
func (*UnimplementedBundleServer) BatchDeleteFederatedBundle(ctx context.Context, req *BatchDeleteFederatedBundleRequest) (*BatchDeleteFederatedBundleResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchDeleteFederatedBundle not implemented")
}

func RegisterBundleServer(s *grpc.Server, srv BundleServer) {
	s.RegisterService(&_Bundle_serviceDesc, srv)
}

func _Bundle_GetBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).GetBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/GetBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).GetBundle(ctx, req.(*GetBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_AppendBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AppendBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).AppendBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/AppendBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).AppendBundle(ctx, req.(*AppendBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_PublishJWTAuthority_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishJWTAuthorityRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).PublishJWTAuthority(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/PublishJWTAuthority",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).PublishJWTAuthority(ctx, req.(*PublishJWTAuthorityRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_ListFederatedBundles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFederatedBundlesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).ListFederatedBundles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/ListFederatedBundles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).ListFederatedBundles(ctx, req.(*ListFederatedBundlesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_GetFederatedBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFederatedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).GetFederatedBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/GetFederatedBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).GetFederatedBundle(ctx, req.(*GetFederatedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchCreateFederatedBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchCreateFederatedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchCreateFederatedBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/BatchCreateFederatedBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchCreateFederatedBundle(ctx, req.(*BatchCreateFederatedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchUpdateFederatedBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchUpdateFederatedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchUpdateFederatedBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/BatchUpdateFederatedBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchUpdateFederatedBundle(ctx, req.(*BatchUpdateFederatedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchSetFederatedBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchSetFederatedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchSetFederatedBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/BatchSetFederatedBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchSetFederatedBundle(ctx, req.(*BatchSetFederatedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Bundle_BatchDeleteFederatedBundle_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchDeleteFederatedBundleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BundleServer).BatchDeleteFederatedBundle(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.api.server.bundle.v1.Bundle/BatchDeleteFederatedBundle",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BundleServer).BatchDeleteFederatedBundle(ctx, req.(*BatchDeleteFederatedBundleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Bundle_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.api.server.bundle.v1.Bundle",
	HandlerType: (*BundleServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetBundle",
			Handler:    _Bundle_GetBundle_Handler,
		},
		{
			MethodName: "AppendBundle",
			Handler:    _Bundle_AppendBundle_Handler,
		},
		{
			MethodName: "PublishJWTAuthority",
			Handler:    _Bundle_PublishJWTAuthority_Handler,
		},
		{
			MethodName: "ListFederatedBundles",
			Handler:    _Bundle_ListFederatedBundles_Handler,
		},
		{
			MethodName: "GetFederatedBundle",
			Handler:    _Bundle_GetFederatedBundle_Handler,
		},
		{
			MethodName: "BatchCreateFederatedBundle",
			Handler:    _Bundle_BatchCreateFederatedBundle_Handler,
		},
		{
			MethodName: "BatchUpdateFederatedBundle",
			Handler:    _Bundle_BatchUpdateFederatedBundle_Handler,
		},
		{
			MethodName: "BatchSetFederatedBundle",
			Handler:    _Bundle_BatchSetFederatedBundle_Handler,
		},
		{
			MethodName: "BatchDeleteFederatedBundle",
			Handler:    _Bundle_BatchDeleteFederatedBundle_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "spire/api/server/bundle/v1/bundle.proto",
}
