// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spire/server/upstreamauthority/upstreamauthority.proto

package upstreamauthority

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	common "github.com/spiffe/spire/proto/spire/common"
	plugin "github.com/spiffe/spire/proto/spire/common/plugin"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type MintX509CARequest struct {
	// Certificate signing request (PKCS#10)
	Csr []byte `protobuf:"bytes,1,opt,name=csr,proto3" json:"csr,omitempty"`
	// Preferred TTL is the TTL preferred by SPIRE server for signed CA. If
	// zero, the plugin should determine its own TTL value. Plugins are free to
	// ignore this and use their own policies around TTLs.
	PreferredTtl         int32    `protobuf:"varint,2,opt,name=preferred_ttl,json=preferredTtl,proto3" json:"preferred_ttl,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MintX509CARequest) Reset()         { *m = MintX509CARequest{} }
func (m *MintX509CARequest) String() string { return proto.CompactTextString(m) }
func (*MintX509CARequest) ProtoMessage()    {}
func (*MintX509CARequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_367b9c0992259cde, []int{0}
}

func (m *MintX509CARequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MintX509CARequest.Unmarshal(m, b)
}
func (m *MintX509CARequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MintX509CARequest.Marshal(b, m, deterministic)
}
func (m *MintX509CARequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintX509CARequest.Merge(m, src)
}
func (m *MintX509CARequest) XXX_Size() int {
	return xxx_messageInfo_MintX509CARequest.Size(m)
}
func (m *MintX509CARequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MintX509CARequest.DiscardUnknown(m)
}

var xxx_messageInfo_MintX509CARequest proto.InternalMessageInfo

func (m *MintX509CARequest) GetCsr() []byte {
	if m != nil {
		return m.Csr
	}
	return nil
}

func (m *MintX509CARequest) GetPreferredTtl() int32 {
	if m != nil {
		return m.PreferredTtl
	}
	return 0
}

type MintX509CAResponse struct {
	// Contains ASN.1 encoded certificates representing the X.509 CA along with
	// any intermediates necessary to chain back to a certificate present in
	// the upstream_x509_roots.
	X509CaChain [][]byte `protobuf:"bytes,1,rep,name=x509_ca_chain,json=x509CaChain,proto3" json:"x509_ca_chain,omitempty"`
	// The trusted X.509 root authorities for the upstream authority
	UpstreamX509Roots    [][]byte `protobuf:"bytes,2,rep,name=upstream_x509_roots,json=upstreamX509Roots,proto3" json:"upstream_x509_roots,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *MintX509CAResponse) Reset()         { *m = MintX509CAResponse{} }
func (m *MintX509CAResponse) String() string { return proto.CompactTextString(m) }
func (*MintX509CAResponse) ProtoMessage()    {}
func (*MintX509CAResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_367b9c0992259cde, []int{1}
}

func (m *MintX509CAResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_MintX509CAResponse.Unmarshal(m, b)
}
func (m *MintX509CAResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_MintX509CAResponse.Marshal(b, m, deterministic)
}
func (m *MintX509CAResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MintX509CAResponse.Merge(m, src)
}
func (m *MintX509CAResponse) XXX_Size() int {
	return xxx_messageInfo_MintX509CAResponse.Size(m)
}
func (m *MintX509CAResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_MintX509CAResponse.DiscardUnknown(m)
}

var xxx_messageInfo_MintX509CAResponse proto.InternalMessageInfo

func (m *MintX509CAResponse) GetX509CaChain() [][]byte {
	if m != nil {
		return m.X509CaChain
	}
	return nil
}

func (m *MintX509CAResponse) GetUpstreamX509Roots() [][]byte {
	if m != nil {
		return m.UpstreamX509Roots
	}
	return nil
}

type PublishJWTKeyRequest struct {
	// The JWT signing key to publish upstream
	JwtKey               *common.PublicKey `protobuf:"bytes,1,opt,name=jwt_key,json=jwtKey,proto3" json:"jwt_key,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *PublishJWTKeyRequest) Reset()         { *m = PublishJWTKeyRequest{} }
func (m *PublishJWTKeyRequest) String() string { return proto.CompactTextString(m) }
func (*PublishJWTKeyRequest) ProtoMessage()    {}
func (*PublishJWTKeyRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_367b9c0992259cde, []int{2}
}

func (m *PublishJWTKeyRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishJWTKeyRequest.Unmarshal(m, b)
}
func (m *PublishJWTKeyRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishJWTKeyRequest.Marshal(b, m, deterministic)
}
func (m *PublishJWTKeyRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishJWTKeyRequest.Merge(m, src)
}
func (m *PublishJWTKeyRequest) XXX_Size() int {
	return xxx_messageInfo_PublishJWTKeyRequest.Size(m)
}
func (m *PublishJWTKeyRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishJWTKeyRequest.DiscardUnknown(m)
}

var xxx_messageInfo_PublishJWTKeyRequest proto.InternalMessageInfo

func (m *PublishJWTKeyRequest) GetJwtKey() *common.PublicKey {
	if m != nil {
		return m.JwtKey
	}
	return nil
}

type PublishJWTKeyResponse struct {
	// The upstream JWT signing keys
	UpstreamJwtKeys      []*common.PublicKey `protobuf:"bytes,1,rep,name=upstream_jwt_keys,json=upstreamJwtKeys,proto3" json:"upstream_jwt_keys,omitempty"`
	XXX_NoUnkeyedLiteral struct{}            `json:"-"`
	XXX_unrecognized     []byte              `json:"-"`
	XXX_sizecache        int32               `json:"-"`
}

func (m *PublishJWTKeyResponse) Reset()         { *m = PublishJWTKeyResponse{} }
func (m *PublishJWTKeyResponse) String() string { return proto.CompactTextString(m) }
func (*PublishJWTKeyResponse) ProtoMessage()    {}
func (*PublishJWTKeyResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_367b9c0992259cde, []int{3}
}

func (m *PublishJWTKeyResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PublishJWTKeyResponse.Unmarshal(m, b)
}
func (m *PublishJWTKeyResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PublishJWTKeyResponse.Marshal(b, m, deterministic)
}
func (m *PublishJWTKeyResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PublishJWTKeyResponse.Merge(m, src)
}
func (m *PublishJWTKeyResponse) XXX_Size() int {
	return xxx_messageInfo_PublishJWTKeyResponse.Size(m)
}
func (m *PublishJWTKeyResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_PublishJWTKeyResponse.DiscardUnknown(m)
}

var xxx_messageInfo_PublishJWTKeyResponse proto.InternalMessageInfo

func (m *PublishJWTKeyResponse) GetUpstreamJwtKeys() []*common.PublicKey {
	if m != nil {
		return m.UpstreamJwtKeys
	}
	return nil
}

func init() {
	proto.RegisterType((*MintX509CARequest)(nil), "spire.server.upstreamauthority.MintX509CARequest")
	proto.RegisterType((*MintX509CAResponse)(nil), "spire.server.upstreamauthority.MintX509CAResponse")
	proto.RegisterType((*PublishJWTKeyRequest)(nil), "spire.server.upstreamauthority.PublishJWTKeyRequest")
	proto.RegisterType((*PublishJWTKeyResponse)(nil), "spire.server.upstreamauthority.PublishJWTKeyResponse")
}

func init() {
	proto.RegisterFile("spire/server/upstreamauthority/upstreamauthority.proto", fileDescriptor_367b9c0992259cde)
}

var fileDescriptor_367b9c0992259cde = []byte{
	// 446 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x53, 0xdf, 0x8b, 0xd3, 0x40,
	0x10, 0x26, 0x57, 0x3c, 0x71, 0xae, 0x45, 0xbb, 0x2a, 0xd6, 0x3e, 0x48, 0x89, 0x28, 0xd5, 0x87,
	0xa4, 0x56, 0x2b, 0x1c, 0x88, 0x70, 0xe6, 0x41, 0xed, 0x21, 0x1c, 0xe1, 0x44, 0x39, 0x84, 0x90,
	0xc6, 0x49, 0xb3, 0x67, 0x9b, 0x8d, 0xfb, 0xc3, 0x33, 0x2f, 0xfe, 0x89, 0xfe, 0x4d, 0x92, 0xdd,
	0x6c, 0x34, 0xf6, 0xe8, 0xdd, 0x3d, 0x6d, 0x98, 0xf9, 0xbe, 0x6f, 0x66, 0xbe, 0xc9, 0xc0, 0x4b,
	0x51, 0x50, 0x8e, 0xbe, 0x40, 0xfe, 0x03, 0xb9, 0xaf, 0x0a, 0x21, 0x39, 0xc6, 0xeb, 0x58, 0xc9,
	0x8c, 0x71, 0x2a, 0xcb, 0xcd, 0x88, 0x57, 0x70, 0x26, 0x19, 0x79, 0xa0, 0x79, 0x9e, 0xe1, 0x79,
	0x1b, 0xa8, 0xe1, 0x7d, 0xa3, 0x9b, 0xb0, 0xf5, 0x9a, 0xe5, 0xf5, 0x63, 0xa8, 0xc3, 0x51, 0x2b,
	0x55, 0xac, 0xd4, 0x92, 0xda, 0xc7, 0x20, 0xdc, 0x39, 0xf4, 0x3f, 0xd0, 0x5c, 0x7e, 0x9e, 0x4d,
	0xf6, 0x83, 0x83, 0x10, 0xbf, 0x2b, 0x14, 0x92, 0xdc, 0x82, 0x4e, 0x22, 0xf8, 0xc0, 0x19, 0x39,
	0xe3, 0x6e, 0x58, 0x7d, 0x92, 0x87, 0xd0, 0x2b, 0x38, 0xa6, 0xc8, 0x39, 0x7e, 0x8d, 0xa4, 0x5c,
	0x0d, 0x76, 0x46, 0xce, 0xf8, 0x5a, 0xd8, 0x6d, 0x82, 0xc7, 0x72, 0xe5, 0x66, 0x40, 0xfe, 0xd5,
	0x12, 0x05, 0xcb, 0x05, 0x12, 0x17, 0x7a, 0x3f, 0x67, 0x93, 0xfd, 0x28, 0x89, 0xa3, 0x24, 0x8b,
	0x69, 0x3e, 0x70, 0x46, 0x9d, 0x71, 0x37, 0xdc, 0xab, 0x82, 0x41, 0x1c, 0x54, 0x21, 0xe2, 0xc1,
	0x6d, 0x3b, 0x57, 0xa4, 0xc1, 0x9c, 0x31, 0x29, 0x06, 0x3b, 0x1a, 0xd9, 0xb7, 0xa9, 0x4a, 0x38,
	0xac, 0x12, 0xee, 0x3b, 0xb8, 0x73, 0xa4, 0x16, 0x2b, 0x2a, 0xb2, 0xf9, 0xa7, 0xe3, 0x43, 0x2c,
	0x6d, 0xe3, 0x13, 0xb8, 0x7e, 0x7a, 0x26, 0xa3, 0x6f, 0x58, 0xea, 0xe6, 0xf7, 0xa6, 0xf7, 0x3c,
	0x63, 0x5e, 0xed, 0x8a, 0x26, 0x25, 0x15, 0x61, 0xf7, 0xf4, 0x4c, 0x1e, 0x62, 0xe9, 0x7e, 0x81,
	0xbb, 0xff, 0x29, 0xd5, 0x6d, 0x07, 0xd0, 0xd4, 0x8d, 0x6a, 0x4d, 0xa1, 0x5b, 0xdf, 0x22, 0x7a,
	0xd3, 0x32, 0xe6, 0x5a, 0x5c, 0x4c, 0x7f, 0x77, 0xa0, 0xff, 0xb1, 0x8e, 0x1d, 0xd8, 0x85, 0x11,
	0x05, 0xf0, 0xd7, 0x27, 0xf2, 0xcc, 0xdb, 0xbe, 0x5f, 0x6f, 0x63, 0x3f, 0xc3, 0xe9, 0x55, 0x28,
	0x66, 0x9e, 0x89, 0x43, 0x7e, 0x41, 0xaf, 0x35, 0x2a, 0x79, 0x71, 0x91, 0xcc, 0x79, 0x1e, 0x0f,
	0x67, 0x57, 0x64, 0x35, 0xf5, 0x4f, 0xe0, 0x46, 0xc0, 0xf2, 0x94, 0x2e, 0x15, 0x47, 0xf2, 0xa8,
	0xed, 0x61, 0xfd, 0x4f, 0x36, 0x79, 0x5b, 0xec, 0xf1, 0x45, 0xb0, 0x7a, 0x5b, 0x29, 0xf4, 0xde,
	0xa2, 0x3c, 0xd2, 0xe9, 0xf7, 0x79, 0xca, 0xc8, 0x93, 0x73, 0x89, 0x2d, 0x8c, 0xad, 0xf1, 0xf4,
	0x32, 0x50, 0x53, 0xe7, 0xcd, 0xeb, 0x93, 0x57, 0x4b, 0x2a, 0x33, 0xb5, 0xa8, 0xd0, 0xbe, 0x28,
	0x68, 0x9a, 0xa2, 0x6f, 0x8e, 0x4c, 0xdf, 0x93, 0xbf, 0xfd, 0xc6, 0x17, 0xbb, 0x1a, 0xf5, 0xfc,
	0x4f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x6b, 0x06, 0xe6, 0x5c, 0x0c, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// UpstreamAuthorityClient is the client API for UpstreamAuthority service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type UpstreamAuthorityClient interface {
	// Mints an X.509 CA and responds with the signed X.509 CA certificate
	// chain and upstream X.509 roots. If supported by the implementation,
	// subsequent responses on the stream contain upstream X.509 root updates,
	// otherwise the RPC is completed after sending the initial response.
	//
	// Implementation note:
	// The stream should be kept open in the face of transient errors
	// encountered while tracking changes to the upstream X.509 roots as SPIRE
	// core will not reopen a closed stream until the next X.509 CA rotation.
	MintX509CA(ctx context.Context, in *MintX509CARequest, opts ...grpc.CallOption) (UpstreamAuthority_MintX509CAClient, error)
	// Publishes a JWT signing key upstream and responds with the upstream JWT
	// keys. If supported by the implementation, subsequent responses on the
	// stream contain upstream JWT key updates, otherwise the RPC is completed
	// after sending the initial response.
	//
	// This RPC is optional and will return NotImplemented if unsupported.
	//
	// Implementation note:
	// The stream should be kept open in the face of transient errors
	// encountered while tracking changes to the upstream JWT keys as SPIRE
	// core will not reopen a closed stream until the next JWT key rotation.
	PublishJWTKey(ctx context.Context, in *PublishJWTKeyRequest, opts ...grpc.CallOption) (UpstreamAuthority_PublishJWTKeyClient, error)
	// Standard SPIRE plugin RPCs
	Configure(ctx context.Context, in *plugin.ConfigureRequest, opts ...grpc.CallOption) (*plugin.ConfigureResponse, error)
	GetPluginInfo(ctx context.Context, in *plugin.GetPluginInfoRequest, opts ...grpc.CallOption) (*plugin.GetPluginInfoResponse, error)
}

type upstreamAuthorityClient struct {
	cc *grpc.ClientConn
}

func NewUpstreamAuthorityClient(cc *grpc.ClientConn) UpstreamAuthorityClient {
	return &upstreamAuthorityClient{cc}
}

func (c *upstreamAuthorityClient) MintX509CA(ctx context.Context, in *MintX509CARequest, opts ...grpc.CallOption) (UpstreamAuthority_MintX509CAClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UpstreamAuthority_serviceDesc.Streams[0], "/spire.server.upstreamauthority.UpstreamAuthority/MintX509CA", opts...)
	if err != nil {
		return nil, err
	}
	x := &upstreamAuthorityMintX509CAClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UpstreamAuthority_MintX509CAClient interface {
	Recv() (*MintX509CAResponse, error)
	grpc.ClientStream
}

type upstreamAuthorityMintX509CAClient struct {
	grpc.ClientStream
}

func (x *upstreamAuthorityMintX509CAClient) Recv() (*MintX509CAResponse, error) {
	m := new(MintX509CAResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *upstreamAuthorityClient) PublishJWTKey(ctx context.Context, in *PublishJWTKeyRequest, opts ...grpc.CallOption) (UpstreamAuthority_PublishJWTKeyClient, error) {
	stream, err := c.cc.NewStream(ctx, &_UpstreamAuthority_serviceDesc.Streams[1], "/spire.server.upstreamauthority.UpstreamAuthority/PublishJWTKey", opts...)
	if err != nil {
		return nil, err
	}
	x := &upstreamAuthorityPublishJWTKeyClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type UpstreamAuthority_PublishJWTKeyClient interface {
	Recv() (*PublishJWTKeyResponse, error)
	grpc.ClientStream
}

type upstreamAuthorityPublishJWTKeyClient struct {
	grpc.ClientStream
}

func (x *upstreamAuthorityPublishJWTKeyClient) Recv() (*PublishJWTKeyResponse, error) {
	m := new(PublishJWTKeyResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *upstreamAuthorityClient) Configure(ctx context.Context, in *plugin.ConfigureRequest, opts ...grpc.CallOption) (*plugin.ConfigureResponse, error) {
	out := new(plugin.ConfigureResponse)
	err := c.cc.Invoke(ctx, "/spire.server.upstreamauthority.UpstreamAuthority/Configure", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *upstreamAuthorityClient) GetPluginInfo(ctx context.Context, in *plugin.GetPluginInfoRequest, opts ...grpc.CallOption) (*plugin.GetPluginInfoResponse, error) {
	out := new(plugin.GetPluginInfoResponse)
	err := c.cc.Invoke(ctx, "/spire.server.upstreamauthority.UpstreamAuthority/GetPluginInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UpstreamAuthorityServer is the server API for UpstreamAuthority service.
type UpstreamAuthorityServer interface {
	// Mints an X.509 CA and responds with the signed X.509 CA certificate
	// chain and upstream X.509 roots. If supported by the implementation,
	// subsequent responses on the stream contain upstream X.509 root updates,
	// otherwise the RPC is completed after sending the initial response.
	//
	// Implementation note:
	// The stream should be kept open in the face of transient errors
	// encountered while tracking changes to the upstream X.509 roots as SPIRE
	// core will not reopen a closed stream until the next X.509 CA rotation.
	MintX509CA(*MintX509CARequest, UpstreamAuthority_MintX509CAServer) error
	// Publishes a JWT signing key upstream and responds with the upstream JWT
	// keys. If supported by the implementation, subsequent responses on the
	// stream contain upstream JWT key updates, otherwise the RPC is completed
	// after sending the initial response.
	//
	// This RPC is optional and will return NotImplemented if unsupported.
	//
	// Implementation note:
	// The stream should be kept open in the face of transient errors
	// encountered while tracking changes to the upstream JWT keys as SPIRE
	// core will not reopen a closed stream until the next JWT key rotation.
	PublishJWTKey(*PublishJWTKeyRequest, UpstreamAuthority_PublishJWTKeyServer) error
	// Standard SPIRE plugin RPCs
	Configure(context.Context, *plugin.ConfigureRequest) (*plugin.ConfigureResponse, error)
	GetPluginInfo(context.Context, *plugin.GetPluginInfoRequest) (*plugin.GetPluginInfoResponse, error)
}

// UnimplementedUpstreamAuthorityServer can be embedded to have forward compatible implementations.
type UnimplementedUpstreamAuthorityServer struct {
}

func (*UnimplementedUpstreamAuthorityServer) MintX509CA(req *MintX509CARequest, srv UpstreamAuthority_MintX509CAServer) error {
	return status.Errorf(codes.Unimplemented, "method MintX509CA not implemented")
}
func (*UnimplementedUpstreamAuthorityServer) PublishJWTKey(req *PublishJWTKeyRequest, srv UpstreamAuthority_PublishJWTKeyServer) error {
	return status.Errorf(codes.Unimplemented, "method PublishJWTKey not implemented")
}
func (*UnimplementedUpstreamAuthorityServer) Configure(ctx context.Context, req *plugin.ConfigureRequest) (*plugin.ConfigureResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configure not implemented")
}
func (*UnimplementedUpstreamAuthorityServer) GetPluginInfo(ctx context.Context, req *plugin.GetPluginInfoRequest) (*plugin.GetPluginInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPluginInfo not implemented")
}

func RegisterUpstreamAuthorityServer(s *grpc.Server, srv UpstreamAuthorityServer) {
	s.RegisterService(&_UpstreamAuthority_serviceDesc, srv)
}

func _UpstreamAuthority_MintX509CA_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(MintX509CARequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UpstreamAuthorityServer).MintX509CA(m, &upstreamAuthorityMintX509CAServer{stream})
}

type UpstreamAuthority_MintX509CAServer interface {
	Send(*MintX509CAResponse) error
	grpc.ServerStream
}

type upstreamAuthorityMintX509CAServer struct {
	grpc.ServerStream
}

func (x *upstreamAuthorityMintX509CAServer) Send(m *MintX509CAResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UpstreamAuthority_PublishJWTKey_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(PublishJWTKeyRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(UpstreamAuthorityServer).PublishJWTKey(m, &upstreamAuthorityPublishJWTKeyServer{stream})
}

type UpstreamAuthority_PublishJWTKeyServer interface {
	Send(*PublishJWTKeyResponse) error
	grpc.ServerStream
}

type upstreamAuthorityPublishJWTKeyServer struct {
	grpc.ServerStream
}

func (x *upstreamAuthorityPublishJWTKeyServer) Send(m *PublishJWTKeyResponse) error {
	return x.ServerStream.SendMsg(m)
}

func _UpstreamAuthority_Configure_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(plugin.ConfigureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpstreamAuthorityServer).Configure(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.server.upstreamauthority.UpstreamAuthority/Configure",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpstreamAuthorityServer).Configure(ctx, req.(*plugin.ConfigureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UpstreamAuthority_GetPluginInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(plugin.GetPluginInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UpstreamAuthorityServer).GetPluginInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/spire.server.upstreamauthority.UpstreamAuthority/GetPluginInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UpstreamAuthorityServer).GetPluginInfo(ctx, req.(*plugin.GetPluginInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _UpstreamAuthority_serviceDesc = grpc.ServiceDesc{
	ServiceName: "spire.server.upstreamauthority.UpstreamAuthority",
	HandlerType: (*UpstreamAuthorityServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Configure",
			Handler:    _UpstreamAuthority_Configure_Handler,
		},
		{
			MethodName: "GetPluginInfo",
			Handler:    _UpstreamAuthority_GetPluginInfo_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "MintX509CA",
			Handler:       _UpstreamAuthority_MintX509CA_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PublishJWTKey",
			Handler:       _UpstreamAuthority_PublishJWTKey_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "spire/server/upstreamauthority/upstreamauthority.proto",
}
